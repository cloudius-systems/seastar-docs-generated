<html lang="en" xml:lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Nadav Har&#8217;El - nyh@ScyllaDB.com">
  <meta name="author" content="Avi Kivity - avi@ScyllaDB.com">
  <title>Asynchronous Programming with Seastar</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #c4a000; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #000000; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #000000; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #000000; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">

body {
color: #000000;
background: #FFFFFF;
font-size: 13pt;
line-height: 1.10;
font-family: arial, sans-serif; margin-left: 15pt;
margin-right: 15pt;
text-align: justify;
}

div#header, header {
border-top: 1px solid #aaa;
border-bottom: 1px solid #aaa;
background: #F0F0C0;	margin: 10pt;
margin-left: 10%;
margin-right: 10%;
}

.title {
color: #000000;
margin: 5pt;
text-align: center;
font-family: serif;
font-weight: bold;
font-size: 32pt;
}

.author, .date {
color: #000000;
margin: 0pt;
text-align: center;
font-family: serif;
font-weight: normal;
font-size: 16pt;
}

div#TOC, nav#TOC {
border-top: 1px solid #aaa;
border-bottom: 1px solid #aaa;
background: #F9F9F9;
margin: 10pt;
margin-left: 20%;
margin-right: 20%;
}
h1, h2, h3, h4, h5, h6 {
color: #EE3300;
}
a {
text-decoration: none;
}
a:link, a:visited {
color: #0000CC;	}
a:hover {
color: #CC0000;
text-decoration: underline;
}

code {
background-color: #FFFFFF;



white-space: pre-wrap; 
white-space: -moz-pre-wrap !important; 
white-space: -pre-wrap; 
white-space: -o-pre-wrap; 
word-wrap: break-word; 

}
pre {
padding: 0.5em;
border: 1px dotted #777;
margin-left: 15pt;
margin-right: 15pt;
}
pre, pre > code {
background-color: #f8f8f8;
}

@media print {
body { font-size: 11pt; }
a { color: black; background: transparent; }
pre { border: 1px solid #aaa; }
}
</style>
</head>
<body><header id="title-block-header">
<h1 class="title">Asynchronous Programming with Seastar</h1>
<p class="author">Nadav Har&#8217;El - nyh@ScyllaDB.com</p>
<p class="author">Avi Kivity - avi@ScyllaDB.com</p>
</header>
<div><a href="index.html">Back to table of contents</a>. Previous: <a href="18.html">18 Introducing Seastar&#8217;s network stack</a>. Next: <a href="20.html">20 Shutting down cleanly</a>.</div><h1 data-number="19" id="sharded-services"><span class="header-section-number">19</span> Sharded services</h1>
<p>In the previous section we saw that a Seastar application usually needs to run its code on all available CPU cores. We saw that the <code>seastar::smp::submit_to()</code> function allows the main function, which initially runs only on the first core, to start the server&#8217;s code on all <code>seastar::smp::count</code> cores.</p>
<p>However, usually one needs not just to run code on each core, but also to have an object that contains the state of this code. Additionally, one may like to interact with those different objects, and also have a mechanism to stop the service running on the different cores.</p>
<p>The <code>seastar::sharded&lt;T&gt;</code> template provides a structured way create such a <em>sharded service</em>. It creates a separate object of type <code>T</code> in each core, and provides mechanisms to interact with those copies, to start some code on each, and finally to cleanly stop the service.</p>
<p>To use <code>seastar::sharded</code>, first create a class for the object holding the state of the service on a single core. For example:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;seastar/core/future.hh&gt;</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a><span class="kw">class</span> my_service {</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true"></a>    <span class="bu">std::</span>string _str;</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true"></a>    my_service(<span class="at">const</span> <span class="bu">std::</span>string&amp; str) : _str(str) { }</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true"></a>    seastar::future&lt;&gt; run() {</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true"></a>        <span class="bu">std::</span>cerr &lt;&lt; <span class="st">"running on "</span> &lt;&lt; seastar::engine().cpu_id() &lt;&lt;</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true"></a>            <span class="st">", _str = "</span> &lt;&lt; _str &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true"></a>        <span class="cf">return</span> seastar::make_ready_future&lt;&gt;();</span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true"></a>    }</span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true"></a>    seastar::future&lt;&gt; stop() {</span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true"></a>        <span class="cf">return</span> seastar::make_ready_future&lt;&gt;();</span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true"></a>    }</span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true"></a>};</span></code></pre></div>
<p>The only mandatory method in this object is <code>stop()</code>, which will be called in each core when we want to stop the sharded service and want to wait until it stops on all cores.</p>
<p>Now let&#8217;s see how to use it:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;seastar/core/sharded.hh&gt;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true"></a>seastar::sharded&lt;my_service&gt; s;</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true"></a></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true"></a>    <span class="cf">return</span> s.start(<span class="bu">std::</span>string(<span class="st">"hello"</span>)).then([] {</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true"></a>        <span class="cf">return</span> s.invoke_on_all([] (my_service&amp; local_service) {</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true"></a>            <span class="cf">return</span> local_service.run();</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true"></a>        });</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true"></a>    }).then([] {</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true"></a>        <span class="cf">return</span> s.stop();</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true"></a>    });</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>The <code>s.start()</code> starts the service by creating a <code>my_service</code> object on each of the cores. The arguments to <code>s.start()</code>, if any (in this example, <code>std::string("hello")</code>), are passed to <code>my_service</code>&#8217;s constructor.</p>
<p>But <code>s.start()</code> did not start running any code yet (besides the object&#8217;s constructor). For that, we have the <code>s.invoke_on_all()</code> which runs the given lambda on all the cores - giving each lambda the local <code>my_service</code> object on that core. In this example, we have a <code>run()</code> method on each object, so we run that.</p>
<p>Finally, at the end of the run we want to give the service on all cores a chance to shut down cleanly, so we call <code>s.stop()</code>. This will call the <code>stop()</code> method on each core&#8217;s object, and wait for all of them to finish. Calling <code>s.stop()</code> before destroying <code>s</code> is mandatory - Seastar will warn you if you forget to do it.</p>
<p>In addition to <code>invoke_on_all()</code> which runs the same code on all shards, another feature a sharded service often needs is for one shard to invoke code another specific shard. This is done by calling the sharded service&#8217;s <code>invoke_on()</code> method. For example:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a>seastar::sharded&lt;my_service&gt; s;</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a>...</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a><span class="cf">return</span> s.invoke_on(<span class="dv">0</span>, [] (my_service&amp; local_service) {</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true"></a>    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">"invoked on "</span> &lt;&lt; seastar::engine().cpu_id() &lt;&lt;</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true"></a>        <span class="st">", _str = "</span> &lt;&lt; local_service._str &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true"></a>});</span></code></pre></div>
<p>This runs the lambda function on shard 0, with a reference to the local <code>my_service</code> object on that shard.</p>
<div><a href="index.html">Back to table of contents</a>. Previous: <a href="18.html">18 Introducing Seastar&#8217;s network stack</a>. Next: <a href="20.html">20 Shutting down cleanly</a>.</div></body></html>