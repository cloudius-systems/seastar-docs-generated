<html lang="en" xml:lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Nadav Har&#8217;El - nyh@ScyllaDB.com">
  <meta name="author" content="Avi Kivity - avi@ScyllaDB.com">
  <title>Asynchronous Programming with Seastar</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #c4a000; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #000000; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #000000; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #000000; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">

body {
color: #000000;
background: #FFFFFF;
font-size: 13pt;
line-height: 1.10;
font-family: arial, sans-serif; margin-left: 15pt;
margin-right: 15pt;
text-align: justify;
}

div#header, header {
border-top: 1px solid #aaa;
border-bottom: 1px solid #aaa;
background: #F0F0C0;	margin: 10pt;
margin-left: 10%;
margin-right: 10%;
}

.title {
color: #000000;
margin: 5pt;
text-align: center;
font-family: serif;
font-weight: bold;
font-size: 32pt;
}

.author, .date {
color: #000000;
margin: 0pt;
text-align: center;
font-family: serif;
font-weight: normal;
font-size: 16pt;
}

div#TOC, nav#TOC {
border-top: 1px solid #aaa;
border-bottom: 1px solid #aaa;
background: #F9F9F9;
margin: 10pt;
margin-left: 20%;
margin-right: 20%;
}
h1, h2, h3, h4, h5, h6 {
color: #EE3300;
}
a {
text-decoration: none;
}
a:link, a:visited {
color: #0000CC;	}
a:hover {
color: #CC0000;
text-decoration: underline;
}

code {
background-color: #FFFFFF;



white-space: pre-wrap; 
white-space: -moz-pre-wrap !important; 
white-space: -pre-wrap; 
white-space: -o-pre-wrap; 
word-wrap: break-word; 

}
pre {
padding: 0.5em;
border: 1px dotted #777;
margin-left: 15pt;
margin-right: 15pt;
}
pre, pre > code {
background-color: #f8f8f8;
}

@media print {
body { font-size: 11pt; }
a { color: black; background: transparent; }
pre { border: 1px solid #aaa; }
}
</style>
</head>
<body><header id="title-block-header">
<h1 class="title">Asynchronous Programming with Seastar</h1>
<p class="author">Nadav Har&#8217;El - nyh@ScyllaDB.com</p>
<p class="author">Avi Kivity - avi@ScyllaDB.com</p>
</header>
<div><a href="index.html">Back to table of contents</a>. Previous: <a href="12.html">12 when_all: Waiting for multiple futures</a>. Next: <a href="14.html">14 Pipes</a>.</div><h1 data-number="13" id="semaphores"><span class="header-section-number">13</span> Semaphores</h1>
<p>Seastar&#8217;s semaphores are the standard computer-science semaphores, adapted for futures. A semaphore is a counter into which you can deposit units or take them away. Taking units from the counter may wait if not enough units are available.</p>
<h2 data-number="13.1" id="limiting-parallelism-with-semaphores"><span class="header-section-number">13.1</span> Limiting parallelism with semaphores</h2>
<p>The most common use for a semaphore in Seastar is for limiting parallelism, i.e., limiting the number of instances of some code which can run in parallel. This can be important when each of the parallel invocations uses a limited resource (e.g., memory) so letting an unlimited number of them run in parallel can exhaust this resource.</p>
<p>Consider a case where an external source of events (e.g., an incoming network request) causes an asynchronous function <code>g()</code> to be called. Imagine that we want to limit the number of concurrent <code>g()</code> operations to 100. I.e., If g() is started when 100 other invocations are still ongoing, we want it to delay its real work until one of the other invocations has completed. We can do this with a semaphore:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a>seastar::future&lt;&gt; g() {</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a>    <span class="at">static</span> <span class="at">thread_local</span> seastar::semaphore limit(<span class="dv">100</span>);</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true"></a>    <span class="cf">return</span> limit.wait(<span class="dv">1</span>).then([] {</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true"></a>        <span class="cf">return</span> slow(); <span class="co">// do the real work of g()</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true"></a>    }).finally([] {</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true"></a>        limit.signal(<span class="dv">1</span>);</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true"></a>    });</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>In this example, the semaphore starts with the counter at 100. The asynchronous operation <code>slow()</code> is only started when we can reduce the counter by one (<code>wait(1)</code>), and when <code>slow()</code> is done, either successfully or with exception, the counter is increased back by one (<code>signal(1)</code>). This way, when 100 operations have already started their work and have not yet finished, the 101st operation will wait, until one of the ongoing operations finishes and returns a unit to the semaphore. This ensures that at each time we have at most 100 concurrent <code>slow()</code> operations running in the above code.</p>
<p>Note how we used a <code>static thread_local</code> semaphore, so that all calls to <code>g()</code> from the same shard count towards the same limit; As usual, a Seastar application is sharded so this limit is separate per shard (CPU thread). This is usually fine, because sharded applications consider resources to be separate per shard.</p>
<p>Luckily, the above code happens to be exception safe: <code>limit.wait(1)</code> can throw an exception when it runs out of memory (keeping a list of waiters), and in that case the semaphore counter is not decreased but the continuations below are not run so it is not increased either. <code>limit.wait(1)</code> can also return an exceptional future when the semaphore is <em>broken</em> (we&#8217;ll discuss this later) but in that case the extra <code>signal()</code> call is ignored. Finally, <code>slow()</code> may also throw, or return an exceptional future, but the <code>finally()</code> ensures the semaphore is still increased.</p>
<p>However, as the application code becomes more complex, it becomes harder to ensure that we never forget to call <code>signal()</code> after the operation is done, regardless of which code path or exceptions happen. As an example of what might go wrong, consider the following <em>buggy</em> code snippet, which differs subtly from the above one, and also appears, on first sight, to be correct:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a>seastar::future&lt;&gt; g() {</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>    <span class="at">static</span> <span class="at">thread_local</span> seastar::semaphore limit(<span class="dv">100</span>);</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true"></a>    <span class="cf">return</span> limit.wait(<span class="dv">1</span>).then([] {</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true"></a>        <span class="cf">return</span> slow().finally([] { limit.signal(<span class="dv">1</span>); });</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true"></a>    });</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>But this version is <strong>not</strong> exception safe: Consider what happens if <code>slow()</code> throws an exception before returning a future (this is different from <code>slow()</code> returning an exceptional future - we discussed this difference in the section about exception handling). In this case, we decreased the counter, but the <code>finally()</code> will never be reached, and the counter will never be increased back. There is a way to fix this code, by replacing the call to <code>slow()</code> with <code>seastar::futurize_invoke(slow)</code>. But the point we&#8217;re trying to make here is not how to fix buggy code, but rather that by using the separate <code>semaphore::wait()</code> and <code>semaphore::signal()</code> functions, you can very easily get things wrong.</p>
<p>For exception safety, in C++ it is generally not recommended to have separate resource acquisition and release functions. Instead, C++ offers safer mechanisms for acquiring a resource (in this case semaphore units) and later releasing it: lambda functions, and RAII (&#8220;resource acquisition is initialization&#8221;):</p>
<p>The lambda-based solution is a function <code>seastar::with_semaphore()</code> which is a shortcut for the code in the examples above:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a>seastar::future&lt;&gt; g() {</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true"></a>    <span class="at">static</span> <span class="at">thread_local</span> seastar::semaphore limit(<span class="dv">100</span>);</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true"></a>    <span class="cf">return</span> seastar::with_semaphore(limit, <span class="dv">1</span>, [] {</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true"></a>        <span class="cf">return</span> slow(); <span class="co">// do the real work of g()</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true"></a>    });</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>with_semaphore()</code>, like the earlier code snippets, waits for the given number of units from the semaphore, then runs the given lambda, and when the future returned by the lambda is resolved, <code>with_semaphore()</code> returns back the units to the semaphore. <code>with_semaphore()</code> returns a future which only resolves after all these steps are done.</p>
<p>The function <code>seastar::get_units()</code> is more general. It provides an exception-safe alternative to <code>seastar::semaphore</code>&#8217;s separate <code>wait()</code> and <code>signal()</code> methods, based on C++&#8217;s RAII philosophy: The function returns an opaque units object, which while held, keeps the semaphore&#8217;s counter decreased - and as soon as this object is destructed, the counter is increased back. With this interface you cannot forget to increase the counter, or increase it twice, or increase without decreasing: The counter will always be decreased once when the units object is created, and if that succeeded, increased when the object is destructed. When the units object is moved into a continuation, no matter how this continuation ends, when the continuation is destructed, the units object is destructed and the units are returned to the semaphore&#8217;s counter. The above examples, written with <code>get_units()</code>, looks like this:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a>seastar::future&lt;&gt; g() {</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true"></a>    <span class="at">static</span> <span class="at">thread_local</span> semaphore limit(<span class="dv">100</span>);</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true"></a>    <span class="cf">return</span> seastar::get_units(limit, <span class="dv">1</span>).then([] (<span class="kw">auto</span> units) {</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true"></a>        <span class="cf">return</span> slow().finally([units = <span class="bu">std::</span>move(units)] {});</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true"></a>    });</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>Note the somewhat convoluted way that <code>get_units()</code> needs to be used: The continuations must be nested because we need the <code>units</code> object to be moved to the last continuation. If <code>slow()</code> returns a future (and does not throw immediately), the <code>finally()</code> continuation captures the <code>units</code> object until everything is done, but does not run any code.</p>
<p>Seastars programmers should generally avoid using the the <code>semaphore::wait()</code> and <code>semaphore::signal()</code> functions directly, and always prefer either <code>with_semaphore()</code> (when applicable) or <code>get_units()</code>.</p>
<h2 data-number="13.2" id="limiting-resource-use"><span class="header-section-number">13.2</span> Limiting resource use</h2>
<p>Because semaphores support waiting for any number of units, not just 1, we can use them for more than simple limiting of the <em>number</em> of parallel invocation. For example, consider we have an asynchronous function <code>using_lots_of_memory(size_t bytes)</code>, which uses <code>bytes</code> bytes of memory, and we want to ensure that not more than 1 MB of memory is used by all parallel invocations of this function &#8212; and that additional calls are delayed until previous calls have finished. We can do this with a semaphore:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a>seastar::future&lt;&gt; using_lots_of_memory(<span class="dt">size_t</span> bytes) {</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true"></a>    <span class="at">static</span> <span class="at">thread_local</span> seastar::semaphore limit(<span class="dv">1000000</span>); <span class="co">// limit to 1MB</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true"></a>    <span class="cf">return</span> seastar::with_semaphore(limit, bytes, [bytes] {</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true"></a>        <span class="co">// do something allocating 'bytes' bytes of memory</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true"></a>    });</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>Watch out that in the above example, a call to <code>using_lots_of_memory(2000000)</code> will return a future that never resolves, because the semaphore will never contain enough units to satisfy the semaphore wait. <code>using_lots_of_memory()</code> should probably check whether <code>bytes</code> is above the limit, and throw an exception in that case. Seastar doesn&#8217;t do this for you.</p>
<h2 data-number="13.3" id="limiting-parallelism-of-loops"><span class="header-section-number">13.3</span> Limiting parallelism of loops</h2>
<p>Above, we looked at a function <code>g()</code> which gets called by some external event, and wanted to control its parallelism. In this section, we look at parallelism of loops, which also can be controlled with semaphores.</p>
<p>Consider the following simple loop:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;seastar/core/sleep.hh&gt;</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true"></a>seastar::future&lt;&gt; slow() {</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true"></a>    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">"."</span>;</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true"></a>    <span class="cf">return</span> seastar::sleep(<span class="bu">std::</span>chrono<span class="bu">::</span>seconds(<span class="dv">1</span>));</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true"></a>}</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true"></a>    <span class="cf">return</span> seastar::repeat([] {</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true"></a>        <span class="cf">return</span> slow().then([] { <span class="cf">return</span> seastar::stop_iteration::no; });</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true"></a>    });</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>This loop runs the <code>slow()</code> function (taking one second to complete) without any parallelism &#8212; the next <code>slow()</code> call starts only when the previous one completed. But what if we do not need to serialize the calls to <code>slow()</code>, and want to allow multiple instances of it to be ongoing concurrently?</p>
<p>Naively, we could achieve more parallelism, by starting the next call to <code>slow()</code> right after the previous call &#8212; ignoring the future returned by the previous call to <code>slow()</code> and not waiting for it to resolve:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::repeat([] {</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true"></a>        slow();</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true"></a>        <span class="cf">return</span> seastar::stop_iteration::no;</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true"></a>    });</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>But in this loop, there is no limit to the amount of parallelism &#8212; millions of <code>sleep()</code> calls might be active in parallel, before the first one ever returned. Eventually, this loop may consume all available memory and crash.</p>
<p>Using a semaphore allows us to run many instances of <code>slow()</code> in parallel, but limit the number of these parallel instances to, in the following example, 100:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(seastar::semaphore(<span class="dv">100</span>), [] (<span class="kw">auto</span>&amp; limit) {</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true"></a>        <span class="cf">return</span> seastar::repeat([&amp;limit] {</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true"></a>            <span class="cf">return</span> limit.wait(<span class="dv">1</span>).then([&amp;limit] {</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true"></a>                seastar::futurize_invoke(slow).finally([&amp;limit] {</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true"></a>                    limit.signal(<span class="dv">1</span>); </span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true"></a>                });</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true"></a>                <span class="cf">return</span> seastar::stop_iteration::no;</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true"></a>            });</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true"></a>        });</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true"></a>    });</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>Note how this code differs from the code we saw above for limiting the number of parallel invocations of a function <code>g()</code>:</p>
<ol type="1">
<li>Here we cannot use a single <code>thread_local</code> semaphore. Each call to <code>f()</code> has its loop with parallelism of 100, so needs its own semaphore &#8220;<code>limit</code>&#8221;, kept alive during the loop with <code>do_with()</code>.</li>
<li>Here we do not wait for <code>slow()</code> to complete before continuing the loop, i.e., we do not <code>return</code> the future chain starting at <code>futurize_invoke(slow)</code>. The loop continues to the next iteration when a semaphore unit becomes available, while (in our example) 99 other operations might be ongoing in the background and we do not wait for them.</li>
</ol>
<p>In the examples in this section, we cannot use the <code>with_semaphore()</code> shortcut. <code>with_semaphore()</code> returns a future which only resolves after the lambda&#8217;s returned future resolves. But in the above example, the loop needs to know when just the semaphore units are available, to start the next iteration &#8212; and not wait for the previous iteration to complete. We could not achieve that with <code>with_semaphore()</code>. But the more general exception-safe idiom, <code>seastar::get_units()</code>, can be used in this case, and is recommended:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(seastar::semaphore(<span class="dv">100</span>), [] (<span class="kw">auto</span>&amp; limit) {</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a>        <span class="cf">return</span> seastar::repeat([&amp;limit] {</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true"></a>            <span class="cf">return</span> seastar::get_units(limit, <span class="dv">1</span>).then([] (<span class="kw">auto</span> units) {</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true"></a>                slow().finally([units = <span class="bu">std::</span>move(units)] {});</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true"></a>                <span class="cf">return</span> seastar::stop_iteration::no;</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true"></a>            });</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true"></a>        });</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true"></a>    });</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>The above examples are not realistic, because they have a never-ending loop and the future returned by <code>f()</code> will never resolve. In more realistic cases, the loop has an end, and at the end of the loop we need to wait for all the background operations which the loop started. We can do this by <code>wait()</code>ing on the original count of the semaphore: When the full count is finally available, it means that <em>all</em> the operations have completed. For example, the following loop ends after 456 iterations:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(seastar::semaphore(<span class="dv">100</span>), [] (<span class="kw">auto</span>&amp; limit) {</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true"></a>        <span class="cf">return</span> seastar::do_for_each(<span class="ex">boost::</span>counting_iterator&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>),</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true"></a>                <span class="ex">boost::</span>counting_iterator&lt;<span class="dt">int</span>&gt;(<span class="dv">456</span>), [&amp;limit] (<span class="dt">int</span> i) {</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true"></a>            <span class="cf">return</span> seastar::get_units(limit, <span class="dv">1</span>).then([] (<span class="kw">auto</span> units) {</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true"></a>                slow().finally([units = <span class="bu">std::</span>move(units)] {});</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true"></a>            });</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true"></a>        }).finally([&amp;limit] {</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true"></a>            <span class="cf">return</span> limit.wait(<span class="dv">100</span>);</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true"></a>        });</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true"></a>    });</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>The last <code>finally</code> is what ensures that we wait for the last operations to complete: After the <code>repeat</code> loop ends (whether successfully or prematurely because of an exception in one of the iterations), we do a <code>wait(100)</code> to wait for the semaphore to reach its original value 100, meaning that all operations that we started have completed. Without this <code>finally</code>, the future returned by <code>f()</code> will resolve <em>before</em> all the iterations of the loop actually completed (the last 100 may still be running).</p>
<p>In the idiom we saw in the above example, the same semaphore is used both for limiting the number of background operations, and later to wait for all of them to complete. Sometimes, we want several different loops to use the same semaphore to limit their <em>total</em> parallelism. In that case we must use a separate mechanism for waiting for the completion of the background operations started by the loop. The most convenient way to wait for ongoing operations is using a gate, which we will describe in detail later. A typical example of a loop whose parallelism is limited by an external semaphore:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a><span class="at">thread_local</span> seastar::semaphore limit(<span class="dv">100</span>);</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(seastar::gate(), [] (<span class="kw">auto</span>&amp; gate) {</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true"></a>        <span class="cf">return</span> seastar::do_for_each(<span class="ex">boost::</span>counting_iterator&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>),</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true"></a>                <span class="ex">boost::</span>counting_iterator&lt;<span class="dt">int</span>&gt;(<span class="dv">456</span>), [&amp;gate] (<span class="dt">int</span> i) {</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true"></a>            <span class="cf">return</span> seastar::get_units(limit, <span class="dv">1</span>).then([&amp;gate] (<span class="kw">auto</span> units) {</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true"></a>                gate.enter();</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true"></a>                seastar::futurize_invoke(slow).finally([&amp;gate, units = <span class="bu">std::</span>move(units)] {</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true"></a>                    gate.leave();</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true"></a>                });</span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true"></a>            });</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true"></a>        }).finally([&amp;gate] {</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true"></a>            <span class="cf">return</span> gate.close();</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true"></a>        });</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true"></a>    });</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>In this code, we use the external semaphore <code>limit</code> to limit the number of concurrent operations, but additionally have a gate specific to this loop to help us wait for all ongoing operations to complete.</p>
<p>TODO: also allow <code>get_units()</code> or something similar on a gate, and use that instead of the explicit gate.enter/gate.leave.</p>
<p>TODO: say something about semaphore fairness - if someone is waiting for a lot of units and later someone asks for 1 unit, will both wait or will the request for 1 unit be satisfied?</p>
<p>TODO: say something about broken semaphores? (or in later section especially about breaking/closing/shutting down/etc?)</p>
<p>TODO: Have a few paragraphs, or even a section, on additional uses of semaphores. One is for mutual exclusion using semaphore(1) - we need to explain why although why in Seastar we don&#8217;t have multiple threads touching the same data, if code is composed of different continuations (i.e., a fiber) it can switch to a different fiber in the middle, so if data needs to be protected between two continuations, it needs a mutex. Another example is something akin to wait_all: we start with a semaphore(0), run a known number N of asynchronous functions with finally sem.signal(), and from all this return the future sem.wait(N). PERHAPS even have a separate section on mutual exclusion, where we begin with semaphore(1) but also mention shared_mutex</p>
<div><a href="index.html">Back to table of contents</a>. Previous: <a href="12.html">12 when_all: Waiting for multiple futures</a>. Next: <a href="14.html">14 Pipes</a>.</div></body></html>