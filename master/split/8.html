<html lang="en" xml:lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Nadav Har&#8217;El - nyh@ScyllaDB.com">
  <meta name="author" content="Avi Kivity - avi@ScyllaDB.com">
  <title>Asynchronous Programming with Seastar</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #c4a000; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #000000; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #000000; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #000000; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">

body {
color: #000000;
background: #FFFFFF;
font-size: 13pt;
line-height: 1.10;
font-family: arial, sans-serif; margin-left: 15pt;
margin-right: 15pt;
text-align: justify;
}

div#header, header {
border-top: 1px solid #aaa;
border-bottom: 1px solid #aaa;
background: #F0F0C0;	margin: 10pt;
margin-left: 10%;
margin-right: 10%;
}

.title {
color: #000000;
margin: 5pt;
text-align: center;
font-family: serif;
font-weight: bold;
font-size: 32pt;
}

.author, .date {
color: #000000;
margin: 0pt;
text-align: center;
font-family: serif;
font-weight: normal;
font-size: 16pt;
}

div#TOC, nav#TOC {
border-top: 1px solid #aaa;
border-bottom: 1px solid #aaa;
background: #F9F9F9;
margin: 10pt;
margin-left: 20%;
margin-right: 20%;
}
h1, h2, h3, h4, h5, h6 {
color: #EE3300;
}
a {
text-decoration: none;
}
a:link, a:visited {
color: #0000CC;	}
a:hover {
color: #CC0000;
text-decoration: underline;
}

code {
background-color: #FFFFFF;



white-space: pre-wrap; 
white-space: -moz-pre-wrap !important; 
white-space: -pre-wrap; 
white-space: -o-pre-wrap; 
word-wrap: break-word; 

}
pre {
padding: 0.5em;
border: 1px dotted #777;
margin-left: 15pt;
margin-right: 15pt;
}
pre, pre > code {
background-color: #f8f8f8;
}

@media print {
body { font-size: 11pt; }
a { color: black; background: transparent; }
pre { border: 1px solid #aaa; }
}
</style>
</head>
<body><header id="title-block-header">
<h1 class="title">Asynchronous Programming with Seastar</h1>
<p class="author">Nadav Har&#8217;El - nyh@ScyllaDB.com</p>
<p class="author">Avi Kivity - avi@ScyllaDB.com</p>
</header>
<div><a href="index.html">Back to table of contents</a>. Previous: <a href="7.html">7 Handling exceptions</a>. Next: <a href="9.html">9 Advanced futures</a>.</div><h1 data-number="8" id="lifetime-management"><span class="header-section-number">8</span> Lifetime management</h1>
<p>An asynchronous function starts an operation which may continue long after the function returns: The function itself returns a <code>future&lt;T&gt;</code> almost immediately, but it may take a while until this future is resolved.</p>
<p>When such an asynchronous operation needs to operate on existing objects, or to use temporary objects, we need to worry about the <em>lifetime</em> of these objects: We need to ensure that these objects do not get destroyed before the asynchronous function completes (or it will try to use the freed object and malfunction or crash), and to also ensure that the object finally get destroyed when it is no longer needed (otherwise we will have a memory leak). Seastar offers a variety of mechanisms for safely and efficiently keeping objects alive for the right duration. In this section we will explore these mechanisms, and when to use each mechanism.</p>
<h2 data-number="8.1" id="passing-ownership-to-continuation"><span class="header-section-number">8.1</span> Passing ownership to continuation</h2>
<p>The most straightforward way to ensure that an object is alive when a continuation runs and is destroyed afterwards is to pass its ownership to the continuation. When continuation <em>owns</em> the object, the object will be kept until the continuation runs, and will be destroyed as soon as the continuation is not needed (i.e., it may have run, or skipped in case of exception and <code>then()</code> continuation).</p>
<p>We already saw above that the way for a continuation to get ownership of an object is through <em>capturing</em>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a>seastar::future&lt;&gt; slow_incr(<span class="dt">int</span> i) {</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).then([i] { <span class="cf">return</span> i + <span class="dv">1</span>; });</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Here the continuation captures the value of <code>i</code>. In other words, the continuation includes a copy of <code>i</code>. When the continuation runs 10ms later, it will have access to this value, and as soon as the continuation finishes its object is destroyed, together with its captured copy of <code>i</code>. The continuation owns this copy of <code>i</code>.</p>
<p>Capturing by value as we did here - making a copy of the object we need in the continuation - is useful mainly for very small objects such as the integer in the previous example. Other objects are expensive to copy, or sometimes even cannot be copied. For example, the following is <strong>not</strong> a good idea:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>seastar::future&lt;&gt; slow_op(<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v) {</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a>    <span class="co">// this makes another copy of v:</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>    <span class="cf">return</span> seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).then([v] { <span class="co">/* do something with v */</span> });</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>This would be inefficient - as the vector <code>v</code>, potentially very long, will be copied and the copy will be saved in the continuation. In this example, there is no reason to copy <code>v</code> - it was anyway passed to the function by value and will not be used again after capturing it into the continuation, as right after the capture, the function returns and destroys its copy of <code>v</code>.</p>
<p>For such cases, C++14 allows <em>moving</em> the object into the continuation:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>seastar::future&lt;&gt; slow_op(<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v) {</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>    <span class="co">// v is not copied again, but instead moved:</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>    <span class="cf">return</span> seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).then([v = <span class="bu">std::</span>move(v)] { <span class="co">/* do something with v */</span> });</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Now, instead of copying the object <code>v</code> into the continuation, it is <em>moved</em> into the continuation. The C++11-introduced move constructor moves the vector&#8217;s data into the continuation and clears the original vector. Moving is a quick operation - for a vector it only requires copying a few small fields such as the pointer to the data. As before, once the continuation is dismissed the vector is destroyed - and its data array (which was moved in the move operation) is finally freed.</p>
<p>TODO: talk about temporary_buffer as an example of an object designed to be moved in this way.</p>
<p>In some cases, moving the object is undesirable. For example, some code keeps references to an object or one of its fields and the references become invalid if the object is moved. In some complex objects, even the move constructor is slow. For these cases, C++ provides the useful wrapper <code>std::unique_ptr&lt;T&gt;</code>. A <code>unique_ptr&lt;T&gt;</code> object owns an object of type <code>T</code> allocated on the heap. When a <code>unique_ptr&lt;T&gt;</code> is moved, the object of type T is not touched at all - just the pointer to it is moved. An example of using <code>std::unique_ptr&lt;T&gt;</code> in capture is:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>seastar::future&lt;&gt; slow_op(<span class="bu">std::</span>unique_ptr&lt;T&gt; p) {</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).then([p = <span class="bu">std::</span>move(p)] { <span class="co">/* do something with *p */</span> });</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>std::unique_ptr&lt;T&gt;</code> is the standard C++ mechanism for passing unique ownership of an object to a function: The object is only owned by one piece of code at a time, and ownership is transferred by moving the <code>unique_ptr</code> object. A <code>unique_ptr</code> cannot be copied: If we try to capture p by value, not by move, we will get a compilation error.</p>
<h2 data-number="8.2" id="keeping-ownership-at-the-caller"><span class="header-section-number">8.2</span> Keeping ownership at the caller</h2>
<p>The technique we described above - giving the continuation ownership of the object it needs to work on - is powerful and safe. But often it becomes hard and verbose to use. When an asynchronous operation involves not just one continuation but a chain of continuations that each needs to work on the same object, we need to pass the ownership of the object between each successive continuation, which can become inconvenient. It is especially inconvenient when we need to pass the same object into two separate asynchronous functions (or continuations) - after we move the object into one, the object needs to be returned so it can be moved again into the second. E.g.,</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a>seastar::future&lt;&gt; slow_op(T o) {</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).then([o = <span class="bu">std::</span>move(o)] {</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>        <span class="co">// first continuation, doing something with o</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>        ...</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>        <span class="co">// return o so the next continuation can use it!</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">std::</span>move(o);</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a>    }).then([](T o) {</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>        <span class="co">// second continuation, doing something with o</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>        ...</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>    });</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a>}</span></code></pre></div>
<p>This complexity arises because we wanted asynchronous functions and continuations to take the ownership of the objects they operated on. A simpler approach would be to have the <em>caller</em> of the asynchronous function continue to be the owner of the object, and just pass <em>references</em> to the object to the various other asynchronous functions and continuations which need the object. For example:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a>seastar::future&lt;&gt; slow_op(T&amp; o) {           <span class="co">// &lt;-- pass by reference</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).then([&amp;o] {<span class="co">// &lt;-- capture by reference</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>        <span class="co">// first continuation, doing something with o</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>        ...</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>    }).then([&amp;o]) {                        <span class="co">// &lt;-- another capture by reference</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a>        <span class="co">// second continuation, doing something with o</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a>        ...</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a>    });</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>This approach raises a question: The caller of <code>slow_op</code> is now responsible for keeping the object <code>o</code> alive while the asynchronous code started by <code>slow_op</code> needs this object. But how will this caller know how long this object is actually needed by the asynchronous operation it started?</p>
<p>The most reasonable answer is that an asynchronous function may need access to its parameters until the future it returns is resolved - at which point the asynchronous code completes and no longer needs access to its parameters. We therefore recommend that Seastar code adopt the following convention:</p>
<blockquote>
<p><strong>Whenever an asynchronous function takes a parameter by reference, the caller must ensure that the referred object lives until the future returned by the function is resolved.</strong></p>
</blockquote>
<p>Note that this is merely a convention suggested by Seastar, and unfortunately nothing in the C++ language enforces it. C++ programmers in non-Seastar programs often pass large objects to functions as a const reference just to avoid a slow copy, and assume that the called function will <em>not</em> save this reference anywhere. But in Seastar code, that is a dangerous practice because even if the asynchronous function did not intend to save the reference anywhere, it may end up doing it implicitly by passing this reference to another function and eventually capturing it in a continuation.</p>
<blockquote>
<p>It would be nice if future versions of C++ could help us catch incorrect uses of references. Perhaps we could have a tag for a special kind of reference, an &#8220;immediate reference&#8221; which a function can use use immediately (i.e, before returning a future), but cannot be captured into a continuation.</p>
</blockquote>
<p>With this convention in place, it is easy to write complex asynchronous functions functions like <code>slow_op</code> which pass the object around, by reference, until the asynchronous operation is done. But how does the caller ensure that the object lives until the returned future is resolved? The following is <em>wrong</em>:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>    T obj; <span class="co">// wrong! will be destroyed too soon!</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>    <span class="cf">return</span> slow_op(obj);</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>It is wrong because the object <code>obj</code> here is local to the call of <code>f</code>, and is destroyed as soon as <code>f</code> returns a future - not when this returned future is resolved! The correct thing for a caller to do would be to create the object <code>obj</code> on the heap (so it does not get destroyed as soon as <code>f</code> returns), and then run <code>slow_op(obj)</code> and when that future resolves (i.e., with <code>.finally()</code>), destroy the object.</p>
<p>Seastar provides a convenient idiom, <code>do_with()</code> for doing this correctly:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(T(), [] (<span class="kw">auto</span>&amp; obj) {</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>        <span class="co">// obj is passed by reference to slow_op, and this is fine:</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a>        <span class="cf">return</span> slow_op(obj);</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>    }</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>do_with</code> will <em>do</em> the given function <em>with</em> the given object alive.</p>
<p><code>do_with</code> saves the given object on the heap, and calls the given lambda with a reference to the new object. Finally it ensures that the new object is destroyed after the returned future is resolved. Usually, do_with is given an <em>rvalue</em>, i.e., an unnamed temporary object or an <code>std::move()</code>ed object, and <code>do_with</code> moves that object into its final place on the heap. <code>do_with</code> returns a future which resolves after everything described above is done (the lambda&#8217;s future is resolved and the object is destroyed).</p>
<p>For convenience, <code>do_with</code> can also be given multiple objects to hold alive. For example here we create two objects and hold alive them until the future resolves:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(T1(), T2(), [] (<span class="kw">auto</span>&amp; obj1, <span class="kw">auto</span>&amp; obj2) {</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a>        <span class="cf">return</span> slow_op(obj1, obj2);</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a>    }</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>While <code>do_with</code> can the lifetime of the objects it holds, if the user accidentally makes copies of these objects, these copies might have the wrong lifetime. Unfortunately, a simple typo like forgetting an &#8220;&amp;&#8221; can cause such accidental copies. For example, the following code is broken:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(T(), [] (T obj) { <span class="co">// WRONG: should be T&amp;, not T</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a>        <span class="cf">return</span> slow_op(obj);</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a>    }</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>In this wrong snippet, <code>obj</code> is mistakenly not a reference to the object which <code>do_with</code> allocated, but rather a copy of it - a copy which is destroyed as soon as the lambda function returns, rather than when the future it returns resolved. Such code will most likely crash because the object is used after being freed. Unfortunately the compiler will not warn about such mistakes. Users should get used to always using the type &#8220;auto&amp;&#8221; with <code>do_with</code> - as in the above correct examples - to reduce the chance of such mistakes.</p>
<p>For the same reason, the following code snippet is also wrong:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a>seastar::future&lt;&gt; slow_op(T obj); <span class="co">// WRONG: should be T&amp;, not T</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a>seastar::future&lt;&gt; f() {</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(T(), [] (<span class="kw">auto</span>&amp; obj) {</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true"></a>        <span class="cf">return</span> slow_op(obj);</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true"></a>    }</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>Here, although <code>obj</code> was correctly passed to the lambda by reference, we later accidentally passed <code>slow_op()</code> a copy of it (because here <code>slow_op</code> takes the object by value, not by reference), and this copy will be destroyed as soon as <code>slow_op</code> returns, not waiting until the returned future resolves.</p>
<p>When using <code>do_with</code>, always remember it requires adhering to the convention described above: The asynchronous function which we call inside <code>do_with</code> must not use the objects held by <code>do_with</code> <em>after</em> the returned future is resolved. It is a serious use-after-free bug for an asynchronous function to return a future which resolves while still having background operations using the <code>do_with()</code>ed objects.</p>
<p>In general, it is rarely a good idea for an asynchronous function to resolve while leaving behind background operations - even if those operations do not use the <code>do_with()</code>ed objects. Background operations that we do not wait for may cause us to run out of memory (if we don&#8217;t limit their number) and make it difficult to shut down the application cleanly.</p>
<h2 data-number="8.3" id="sharing-ownership-reference-counting"><span class="header-section-number">8.3</span> Sharing ownership (reference counting)</h2>
<p>In the beginning of this chapter, we already noted that capturing a copy of an object into a continuation is the simplest way to ensure that the object is alive when the continuation runs and destroyed afterwards. However, complex objects are often expensive (in time and memory) to copy. Some objects cannot be copied at all, or are read-write and the continuation should modify the original object, not a new copy. The solution to all these issues are <strong>reference counted</strong>, a.k.a. <strong>shared</strong> objects:</p>
<p>A simple example of a reference-counted object in Seastar is a <code>seastar::file</code>, an object holding an open file object (we will introduce <code>seastar::file</code> in a later section). A <code>file</code> object can be copied, but copying does not involve copying the file descriptor (let alone the file). Instead, both copies point to the same open file, and a reference count is increased by 1. When a file object is destroyed, the file&#8217;s reference count is decreased by one, and only when the reference count reaches 0 the underlying file is actually closed.</p>
<p>The fact that <code>file</code> objects can be copied very quickly and all copies actually point to the same file, make it very convenient to pass them to asynchronous code; For example,</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a>seastar::future&lt;<span class="dt">uint64_t</span>&gt; slow_size(file f) {</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).then([f] {</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a>        <span class="cf">return</span> f.size();</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>    });</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>Note how calling <code>slow_size</code> is as simple as calling <code>slow_size(f)</code>, passing a copy of <code>f</code>, without needing to do anything special to ensure that <code>f</code> is only destroyed when no longer needed. That simply happens naturally when nothing refers to <code>f</code> any more.</p>
<p>You may wonder why <code>return f.size()</code> in the above example is safe: Doesn&#8217;t it start an asynchronous operation on <code>f</code> (the file&#8217;s size may be stored on disk, so not immediately available), and <code>f</code> may be immediately destroyed when we return and nothing keeps holding a copy of <code>f</code>? If <code>f</code> is really the last reference, that is indeed a bug, but there is another one: the file is never closed. The assumption that makes the code valid is that there is another reference to <code>f</code> that will be used to close it. The close member function holds on to the reference count of that object, so it continues to live even if nothing else keeps holding on to it. Since all futures produced by a file object complete before it is closed, all that is needed for correctness is to remember to always close files.</p>
<p>The reference counting has a run-time cost, but it is usually very small; It is important to remember that Seastar objects are always used by a single CPU only, so the reference-count increment and decrement operations are not the slow atomic operations often used for reference counting, but just regular CPU-local integer operations. Moreover, judicious use of <code>std::move()</code> and the compiler&#8217;s optimizer can reduce the number of unnecessary back-and-forth increment and decrement of the reference count.</p>
<p>C++11 offers a standard way of creating reference-counted shared objects - using the template <code>std::shared_ptr&lt;T&gt;</code>. A <code>shared_ptr</code> can be used to wrap any type into a reference-counted shared object like <code>seastar::file</code> above. However, the standard <code>std::shared_ptr</code> was designed with multi-threaded applications in mind so it uses slow atomic increment/decrement operations for the reference count which we already noted is unnecessary in Seastar. For this reason Seastar offers its own single-threaded implementation of this template, <code>seastar::shared_ptr&lt;T&gt;</code>. It is similar to <code>std::shared_ptr&lt;T&gt;</code> except no atomic operations are used.</p>
<p>Additionally, Seastar also provides an even lower overhead variant of <code>shared_ptr</code>: <code>seastar::lw_shared_ptr&lt;T&gt;</code>. The full-featured <code>shared_ptr</code> is complicated by the need to support polymorphic types correctly (a shared object created of one class, and accessed through a pointer to a base class). It makes <code>shared_ptr</code> need to add two words to the shared object, and two words to each <code>shared_ptr</code> copy. The simplified <code>lw_shared_ptr</code> - which does <strong>not</strong> support polymorphic types - adds just one word in the object (the reference count) and each copy is just one word - just like copying a regular pointer. For this reason, the light-weight <code>seastar::lw_shared_ptr&lt;T&gt;</code> should be preferred when possible (<code>T</code> is not a polymorphic type), otherwise <code>seastar::shared_ptr&lt;T&gt;</code>. The slower <code>std::shared_ptr&lt;T&gt;</code> should never be used in sharded Seastar applications.</p>
<h2 data-number="8.4" id="saving-objects-on-the-stack"><span class="header-section-number">8.4</span> Saving objects on the stack</h2>
<p>Wouldn&#8217;t it be convenient if we could save objects on a stack just like we normally do in synchronous code? I.e., something like:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a><span class="dt">int</span> i = ...;</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).get();</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true"></a><span class="cf">return</span> i;</span></code></pre></div>
<p>Seastar allows writing such code, by using a <code>seastar::thread</code> object which comes with its own stack. A complete example using a <code>seastar::thread</code> might look like this:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a>seastar::future&lt;&gt; slow_incr(<span class="dt">int</span> i) {</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::async([i] {</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true"></a>        seastar::sleep(<span class="dv">10</span><span class="bu">ms</span>).get();</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true"></a>        <span class="co">// We get here after the 10ms of wait, i is still available.</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true"></a>        <span class="cf">return</span> i + <span class="dv">1</span>;</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true"></a>    });</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>We present <code>seastar::thread</code>, <code>seastar::async()</code> and <code>seastar::future::get()</code> in the <a href="25.html#seastarthread">seastar::thread</a> section.</p>
<div><a href="index.html">Back to table of contents</a>. Previous: <a href="7.html">7 Handling exceptions</a>. Next: <a href="9.html">9 Advanced futures</a>.</div></body></html>