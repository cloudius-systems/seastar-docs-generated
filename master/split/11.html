<html lang="en" xml:lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Nadav Har&#8217;El - nyh@ScyllaDB.com">
  <meta name="author" content="Avi Kivity - avi@ScyllaDB.com">
  <title>Asynchronous Programming with Seastar</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #c4a000; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #000000; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #000000; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #000000; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">

body {
color: #000000;
background: #FFFFFF;
font-size: 13pt;
line-height: 1.10;
font-family: arial, sans-serif; margin-left: 15pt;
margin-right: 15pt;
text-align: justify;
}

div#header, header {
border-top: 1px solid #aaa;
border-bottom: 1px solid #aaa;
background: #F0F0C0;	margin: 10pt;
margin-left: 10%;
margin-right: 10%;
}

.title {
color: #000000;
margin: 5pt;
text-align: center;
font-family: serif;
font-weight: bold;
font-size: 32pt;
}

.author, .date {
color: #000000;
margin: 0pt;
text-align: center;
font-family: serif;
font-weight: normal;
font-size: 16pt;
}

div#TOC, nav#TOC {
border-top: 1px solid #aaa;
border-bottom: 1px solid #aaa;
background: #F9F9F9;
margin: 10pt;
margin-left: 20%;
margin-right: 20%;
}
h1, h2, h3, h4, h5, h6 {
color: #EE3300;
}
a {
text-decoration: none;
}
a:link, a:visited {
color: #0000CC;	}
a:hover {
color: #CC0000;
text-decoration: underline;
}

code {
background-color: #FFFFFF;



white-space: pre-wrap; 
white-space: -moz-pre-wrap !important; 
white-space: -pre-wrap; 
white-space: -o-pre-wrap; 
word-wrap: break-word; 

}
pre {
padding: 0.5em;
border: 1px dotted #777;
margin-left: 15pt;
margin-right: 15pt;
}
pre, pre > code {
background-color: #f8f8f8;
}

@media print {
body { font-size: 11pt; }
a { color: black; background: transparent; }
pre { border: 1px solid #aaa; }
}
</style>
</head>
<body><header id="title-block-header">
<h1 class="title">Asynchronous Programming with Seastar</h1>
<p class="author">Nadav Har&#8217;El - nyh@ScyllaDB.com</p>
<p class="author">Avi Kivity - avi@ScyllaDB.com</p>
</header>
<div><a href="index.html">Back to table of contents</a>. Previous: <a href="10.html">10 Fibers</a>. Next: <a href="12.html">12 when_all: Waiting for multiple futures</a>.</div><h1 data-number="11" id="loops"><span class="header-section-number">11</span> Loops</h1>
<p>A majority of time-consuming computations involve using loops. Seastar provides several primitives for expressing them in a way that composes nicely with the future/promise model. A very important aspect of Seastar loop primitives is that each iteration is followed by a preemption point, thus allowing other tasks to run inbetween iterations.</p>
<h2 data-number="11.1" id="repeat"><span class="header-section-number">11.1</span> repeat</h2>
<p>A loop created with <code>repeat</code> executes its body until it receives a <code>stop_iteration</code> object, which informs if the iteration should continue (<code>stop_iteration::no</code>) or stop (<code>stop_iteration::yes</code>). Next iteration will be launched only after the first one has finished. The loop body passed to <code>repeat</code> is expected to have a <code>future&lt;stop_iteration&gt;</code> return type.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a>seastar::future&lt;<span class="dt">int</span>&gt; recompute_number(<span class="dt">int</span> number);</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a>seastar::future&lt;&gt; push_until_100(seastar::lw_shared_ptr&lt;<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&gt; queue, <span class="dt">int</span> element) {</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a>    <span class="cf">return</span> seastar::repeat([queue, element] {</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a>        <span class="cf">if</span> (queue-&gt;size() == <span class="dv">100</span>) {</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a>            <span class="cf">return</span> make_ready_future&lt;stop_iteration&gt;(stop_iteration::yes);</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a>        }</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a>        <span class="cf">return</span> recompute_number(element).then([queue] (<span class="dt">int</span> new_element) {</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a>            queue-&gt;push_back(new_element);</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a>            <span class="cf">return</span> stop_iteration::no;</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a>        });</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true"></a>    });</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true"></a>}</span></code></pre></div>
<h2 data-number="11.2" id="do_until"><span class="header-section-number">11.2</span> do_until</h2>
<p>Do until is a close relative of <code>repeat</code>, but it uses an explicitly passed condition to decide whether it should stop iterating. The above example could be expressed with <code>do_until</code> as follows:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a>seastar::future&lt;<span class="dt">int</span>&gt; recompute_number(<span class="dt">int</span> number);</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true"></a>seastar::future&lt;&gt; push_until_100(seastar::lw_shared_ptr&lt;<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&gt; queue, <span class="dt">int</span> element) {</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_until([queue] { <span class="cf">return</span> queue-&gt;size() == <span class="dv">100</span>; }, [queue, element] {</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true"></a>        <span class="cf">return</span> recompute_number(element).then([queue] (<span class="dt">int</span> new_element) {</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true"></a>            queue-&gt;push_back(new_element);</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true"></a>        });</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true"></a>    });</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>Note that the loop body is expected to return a <code>future&lt;&gt;</code>, which allows composing complex continuations inside the loop.</p>
<h2 data-number="11.3" id="do_for_each"><span class="header-section-number">11.3</span> do_for_each</h2>
<p>A <code>do_for_each</code> is an equivalent of a <code>for</code> loop in Seastar world. It accepts a range (or a pair of iterators) and a function body, which it applies to each argument, in order, one by one. The next iteration will be launched only after the first one has finished, as was the case with <code>repeat</code>. As usual, <code>do_for_each</code> expects its loop body to return a <code>future&lt;&gt;</code>.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a>seastar::future&lt;&gt; append(seastar::lw_shared_ptr&lt;<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&gt; queue1, seastar::lw_shared_ptr&lt;<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&gt; queue2) {</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_for_each(queue2, [queue1] (<span class="dt">int</span> element) {</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true"></a>        queue1-&gt;push_back(element);</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true"></a>    });</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true"></a>}</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true"></a>seastar::future&lt;&gt; append_iota(seastar::lw_shared_ptr&lt;<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&gt; queue1, <span class="dt">int</span> n) {</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_for_each(<span class="ex">boost::</span>make_counting_iterator&lt;<span class="dt">size_t</span>&gt;(<span class="dv">0</span>), <span class="ex">boost::</span>make_counting_iterator&lt;<span class="dt">size_t</span>&gt;(n), [queue1] (<span class="dt">int</span> element) {</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true"></a>        queue1-&gt;push_back(element);</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true"></a>    });</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>do_for_each</code> accepts either an lvalue reference to a container or a pair of iterators. It implies that the responsibility to ensure that the container is alive during the whole loop execution belongs to the caller. If the container needs its lifetime prolonged, it can be easily achieved with <code>do_with</code>:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a>seastar::future&lt;&gt; do_something(<span class="dt">int</span> number);</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true"></a>seastar::future&lt;&gt; do_for_all(<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; numbers) {</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true"></a>    <span class="co">// Note that the "numbers" vector will be destroyed as soon as this function</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true"></a>    <span class="co">// returns, so we use do_with to guarantee it lives during the whole loop execution:</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true"></a>    <span class="cf">return</span> seastar::do_with(<span class="bu">std::</span>move(numbers), [] (<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&amp; numbers) {</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true"></a>        <span class="cf">return</span> seastar::do_for_each(numbers, [] (<span class="dt">int</span> number) {</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true"></a>            <span class="cf">return</span> do_something(number);</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true"></a>        });</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true"></a>    });</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true"></a>}</span></code></pre></div>
<h2 data-number="11.4" id="parallel_for_each"><span class="header-section-number">11.4</span> parallel_for_each</h2>
<p>Parallel for each is a high concurrency variant of <code>do_for_each</code>. When using <code>parallel_for_each</code>, all iterations are queued simultaneously - which means that there&#8217;s no guarantee in which order they finish their operations.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a>seastar::future&lt;&gt; flush_all_files(seastar::lw_shared_ptr&lt;<span class="bu">std::</span>vector&lt;seastar::file&gt;&gt; files) {</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::parallel_for_each(files, [] (seastar::file f) {</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true"></a>        <span class="co">// file::flush() returns a future&lt;&gt;</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true"></a>        <span class="cf">return</span> f.flush();</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true"></a>    });</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>parallel_for_each</code> is a powerful tool, as it allows spawning many tasks in parallel. It can be a great performance gain, but there are also caveats. First of all, too high concurrency may be troublesome - the details can be found in chapter <strong>Limiting parallelism of loops</strong>.</p>
<p>To restrict the concurrency of <code>parallel_for_each</code> by an integer number, use <code>max_concurrent_for_each</code> that is described below. More details about dealing with parallelism can be found in chapter <strong>Limiting parallelism of loops</strong>.</p>
<p>Secondly, take note that the order in which iterations will be executed within a <code>parallel_for_each</code> loop is arbitrary - if a strict ordering is needed, consider using <code>do_for_each</code> instead.</p>
<p>TODO: map_reduce, as a shortcut (?) for parallel_for_each which needs to produce some results (e.g., logical_or of boolean results), so we don&#8217;t need to create a lw_shared_ptr explicitly (or do_with).</p>
<p>TODO: See seastar commit &#8220;input_stream: Fix possible infinite recursion in consume()&#8221; for an example on why recursion is a possible, but bad, replacement for repeat(). See also my comment on https://groups.google.com/d/msg/seastar-dev/CUkLVBwva3Y/3DKGw-9aAQAJ on why Seastar&#8217;s iteration primitives should be used over tail call optimization.</p>
<h2 data-number="11.5" id="max_concurrent_for_each"><span class="header-section-number">11.5</span> max_concurrent_for_each</h2>
<p>Max concurrent for each is a variant of <code>parallel_for_each</code> with restricted parallelism. It accepts an additional parameter - <code>max_concurrent</code> - with which, up to <code>max_concurrent</code> iterations are queued simultaneously, with no guarantee in which order they finish their operations.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a>seastar::future&lt;&gt; flush_all_files(seastar::lw_shared_ptr&lt;<span class="bu">std::</span>vector&lt;seastar::file&gt;&gt; files, <span class="dt">size_t</span> max_concurrent) {</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true"></a>    <span class="cf">return</span> seastar::max_concurrent_for_each(files, max_concurrent, [] (seastar::file f) {</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true"></a>        <span class="cf">return</span> f.flush();</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true"></a>    });</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>Determining the maximum concurrency limit is out of the scope of this document. It should typically be derived from the actual capabilities of the system the software is running on, like the number of parallel execution units or I/O channels, so to optimize utilization of resources without overwhelming the system.</p>
<div><a href="index.html">Back to table of contents</a>. Previous: <a href="10.html">10 Fibers</a>. Next: <a href="12.html">12 when_all: Waiting for multiple futures</a>.</div></body></html>