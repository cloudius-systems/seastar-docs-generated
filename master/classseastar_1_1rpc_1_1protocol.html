<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Seastar: seastar::rpc::protocol&lt; Serializer, MsgType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Seastar
   </div>
   <div id="projectbrief">High performance C++ framework for concurrent servers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceseastar.html">seastar</a></li><li class="navelem"><b>rpc</b></li><li class="navelem"><a class="el" href="classseastar_1_1rpc_1_1protocol.html">protocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classseastar_1_1rpc_1_1protocol-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seastar::rpc::protocol&lt; Serializer, MsgType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group__rpc.html">rpc - remote procedure call framework</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Serializer, typename MsgType = uint32_t&gt;<br />
class seastar::rpc::protocol&lt; Serializer, MsgType &gt;</h3>

<p>Defines a protocol for communication between a server and a client.</p>
<p>A protocol is defined by a <code>Serializer</code> and a <code>MsgType</code>. The <code>Serializer</code> is responsible for serializing and unserializing all types used as arguments and return types used in the protocol. The <code>Serializer</code> is expected to define a <code>read()</code> and <code>write()</code> method for each such type <code>T</code> as follows: </p><pre class="fragment">template &lt;typename Output&gt;
void write(const serializer&amp;, Output&amp; output, const T&amp; data);

template &lt;typename Input&gt;
T read(const serializer&amp;, Input&amp; input, type&lt;T&gt; type_tag);  // type_tag used to disambiguate
</pre><p> Where <code>Input</code> and <code>Output</code> have a <code>void read(char*, size_t)</code> and <code>write(const char*, size_t)</code> respectively. <code>MsgType</code> defines the type to be used as the message id, the id which is used to identify different messages used in the protocol. These are also often referred to as "verbs". The client will use the message id, to specify the remote method (verb) to invoke on the server. The server uses the message id to dispatch the incoming call to the right handler. <code>MsgType</code> should be hashable and serializable. It is preferable to use enum for message types, but do not forget to provide hash function for it.</p>
<p>Use <a class="el" href="classseastar_1_1rpc_1_1protocol.html#ae72396a036b321136ffb0b9d85a3ccff">register_handler()</a> on the server to define the available verbs and the code to be executed when they are invoked by clients. Use <a class="el" href="classseastar_1_1rpc_1_1protocol.html#aa0fa06b9b1b27f9b12f65f0fc2f3a847">make_client()</a> on the client to create a matching callable that can be used to invoke the verb on the server and wait for its result. Note that <a class="el" href="classseastar_1_1rpc_1_1protocol.html#ae72396a036b321136ffb0b9d85a3ccff">register_handler()</a> also returns a client, that can be used to invoke the registered verb on another node (given that the other node has the same verb). This is useful for symmetric protocols, where two or more nodes all have servers as well as connect to the other nodes as clients.</p>
<p>Use <a class="el" href="classseastar_1_1rpc_1_1protocol_1_1server.html" title="Represents the listening port and all accepted connections.">protocol::server</a> to listen for and accept incoming connections on the server and <a class="el" href="classseastar_1_1rpc_1_1protocol_1_1client.html" title="Represents a client side connection.">protocol::client</a> to establish connections to the server. Note that registering the available verbs can be done before/after listening for connections, but best to ensure that by the time incoming requests are to be expected, all the verbs are set-up.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Configuration</h2>
<p>TODO</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Isolation</h2>
<p>RPC supports isolating verb handlers from each other. There are two ways to achieve this: per-handler isolation (the old way) and per-connection isolation (the new way). If no isolation is configured, all handlers will be executed in the context of the <a class="el" href="classseastar_1_1scheduling__group.html" title="Identifies function calls that are accounted as a group.">scheduling_group</a> in which the <a class="el" href="classseastar_1_1rpc_1_1protocol_1_1server.html" title="Represents the listening port and all accepted connections.">protocol::server</a> was created.</p>
<p>Per-handler isolation (the old way) can be configured by using the <a class="el" href="classseastar_1_1rpc_1_1protocol.html#ae72396a036b321136ffb0b9d85a3ccff">register_handler()</a> overload which takes a <a class="el" href="classseastar_1_1scheduling__group.html" title="Identifies function calls that are accounted as a group.">scheduling_group</a>. When invoked, the body of the handler will be executed from the context of the configured <a class="el" href="classseastar_1_1scheduling__group.html" title="Identifies function calls that are accounted as a group.">scheduling_group</a>.</p>
<p>Per-connection isolation (the new way) is a more flexible mechanism that requires user application provided logic to determine how connections are isolated. This mechanism has two parts, the server and the client part. The client configures isolation by setting <a class="el" href="group__rpc.html#acd3e23c31cb27aa7af0099e758d6b733">client_options::isolation_cookie</a>. This cookie is an opaque (to the RPC layer) string that is to be interpreted on the server using user application provided logic. The application provides this logic to the server by setting resource_limits::isolate_connection to an appropriate handler function, that interprets the opaque cookie and resolves it to an <a class="el" href="group__rpc.html#structseastar_1_1rpc_1_1isolation__config" title="Specifies resource isolation for a connection.">isolation_config</a>. The <a class="el" href="classseastar_1_1scheduling__group.html" title="Identifies function calls that are accounted as a group.">scheduling_group</a> in the former will be used not just to execute all verb handlers, but also the connection loop itself, hence providing better isolation.</p>
<p>There a few gotchas related to mixing the two isolation mechanisms. This can happen when the application is updated and one of the client/server is still using the old/new mechanism. In general per-connection isolation overrides the per-handler one. If both are set up, the former will determine the <a class="el" href="classseastar_1_1scheduling__group.html" title="Identifies function calls that are accounted as a group.">scheduling_group</a> context for the handlers. If the client is not configured to send an isolation cookie, the server's resource_limits::isolate_connection will not be invoked and the server will fall back to per-handler isolation if configured. If the client is configured to send an isolation cookie but the server doesn't have a resource_limits::isolate_connection configured, it will use <a class="el" href="group__rpc.html#ga4bcc6887c3b9f6cb6afc5f64b02e0868">default_isolate_connection()</a> to interpret the cookie. Note that this still overrides the per-handler isolation if any is configured. If the server is so old that it doesn't have the per-connection isolation feature at all, it will of course just use the per-handler one, if configured.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Compatibility</h2>
<p>TODO</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Serializer</td><td>the serializer for the protocol. </td></tr>
    <tr><td class="paramname">MsgType</td><td>the type to be used as the message id or verb id. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;<a class="el" href="rpc_8hh_source.html">seastar/rpc/rpc.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for seastar::rpc::protocol&lt; Serializer, MsgType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classseastar_1_1rpc_1_1protocol.png" usemap="#seastar::rpc::protocol_3C_20Serializer_2C_20MsgType_20_3E_map" alt=""/>
  <map id="seastar::rpc::protocol_3C_20Serializer_2C_20MsgType_20_3E_map" name="seastar::rpc::protocol_3C_20Serializer_2C_20MsgType_20_3E_map">
<area href="classseastar_1_1rpc_1_1protocol__base.html" alt="seastar::rpc::protocol_base" shape="rect" coords="0,0,269,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol_1_1client.html">client</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a client side connection.  <a href="classseastar_1_1rpc_1_1protocol_1_1client.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol_1_1server.html">server</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the listening port and all accepted connections.  <a href="classseastar_1_1rpc_1_1protocol_1_1server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e412f12d95dd00ab567e4fe727aaa0f"><td class="memItemLeft" align="right" valign="top"><a id="a5e412f12d95dd00ab567e4fe727aaa0f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>protocol</b> (Serializer &amp;&amp;serializer)</td></tr>
<tr class="separator:a5e412f12d95dd00ab567e4fe727aaa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fa06b9b1b27f9b12f65f0fc2f3a847"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:aa0fa06b9b1b27f9b12f65f0fc2f3a847"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol.html#aa0fa06b9b1b27f9b12f65f0fc2f3a847">make_client</a> (MsgType t)</td></tr>
<tr class="separator:aa0fa06b9b1b27f9b12f65f0fc2f3a847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72396a036b321136ffb0b9d85a3ccff"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ae72396a036b321136ffb0b9d85a3ccff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol.html#ae72396a036b321136ffb0b9d85a3ccff">register_handler</a> (MsgType t, Func &amp;&amp;func)</td></tr>
<tr class="separator:ae72396a036b321136ffb0b9d85a3ccff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fbb6597b5ad698be3f2e42f5499c69"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a77fbb6597b5ad698be3f2e42f5499c69"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol.html#a77fbb6597b5ad698be3f2e42f5499c69">register_handler</a> (MsgType t, <a class="el" href="classseastar_1_1scheduling__group.html">scheduling_group</a> sg, Func &amp;&amp;func)</td></tr>
<tr class="separator:a77fbb6597b5ad698be3f2e42f5499c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea92d1b5ddbf34c72a46e9cb17eff5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol.html#aea92d1b5ddbf34c72a46e9cb17eff5fe">unregister_handler</a> (MsgType t)</td></tr>
<tr class="separator:aea92d1b5ddbf34c72a46e9cb17eff5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1080ac03247263174a9b3b3c605f19d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol.html#a1080ac03247263174a9b3b3c605f19d1">set_logger</a> (std::function&lt; void(const sstring &amp;)&gt; <a class="el" href="classseastar_1_1rpc_1_1logger.html">logger</a>)</td></tr>
<tr class="separator:a1080ac03247263174a9b3b3c605f19d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ac72d6fa744b57b2aead4245058207"><td class="memItemLeft" align="right" valign="top"><a id="aa1ac72d6fa744b57b2aead4245058207"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol.html#aa1ac72d6fa744b57b2aead4245058207">set_logger</a> (::<a class="el" href="classseastar_1_1logger.html">seastar::logger</a> *<a class="el" href="classseastar_1_1rpc_1_1logger.html">logger</a>)</td></tr>
<tr class="memdesc:aa1ac72d6fa744b57b2aead4245058207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a logger to be used to log messages. <br /></td></tr>
<tr class="separator:aa1ac72d6fa744b57b2aead4245058207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26cfa6778e71f53ddb298dea271bfb1"><td class="memItemLeft" align="right" valign="top"><a id="aa26cfa6778e71f53ddb298dea271bfb1"></a>
const <a class="el" href="classseastar_1_1rpc_1_1logger.html">logger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_logger</b> () const</td></tr>
<tr class="separator:aa26cfa6778e71f53ddb298dea271bfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7e8f52c7aa3a9460172195aff61027"><td class="memItemLeft" align="right" valign="top"><a id="a9f7e8f52c7aa3a9460172195aff61027"></a>
<a class="el" href="classseastar_1_1shared__ptr.html">shared_ptr</a>&lt; <a class="el" href="classseastar_1_1rpc_1_1server_1_1connection.html">rpc::server::connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_server_connection</b> (<a class="el" href="classseastar_1_1rpc_1_1server.html">rpc::server</a> &amp;<a class="el" href="classseastar_1_1rpc_1_1protocol_1_1server.html">server</a>, <a class="el" href="classseastar_1_1connected__socket.html">connected_socket</a> fd, <a class="el" href="classseastar_1_1socket__address.html">socket_address</a> addr, <a class="el" href="classseastar_1_1rpc_1_1connection__id.html">connection_id</a> id) override</td></tr>
<tr class="separator:a9f7e8f52c7aa3a9460172195aff61027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6552c0e3b4e1ccffefb8301a2e9e4f7"><td class="memItemLeft" align="right" valign="top"><a id="ab6552c0e3b4e1ccffefb8301a2e9e4f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_handler</b> (MsgType msg_id)</td></tr>
<tr class="separator:ab6552c0e3b4e1ccffefb8301a2e9e4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197731a86477497af43b8650b3327079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1rpc_1_1protocol.html#a197731a86477497af43b8650b3327079">has_handlers</a> () const noexcept</td></tr>
<tr class="separator:a197731a86477497af43b8650b3327079"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad99114455d7abdf6683d69026624221b"><td class="memItemLeft" align="right" valign="top"><a id="ad99114455d7abdf6683d69026624221b"></a>
friend&#160;</td><td class="memItemRight" valign="bottom"><b>server</b></td></tr>
<tr class="separator:ad99114455d7abdf6683d69026624221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a197731a86477497af43b8650b3327079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197731a86477497af43b8650b3327079">&#9670;&nbsp;</a></span>has_handlers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Serializer , typename MsgType  = uint32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classseastar_1_1rpc_1_1protocol.html">seastar::rpc::protocol</a>&lt; Serializer, MsgType &gt;::has_handlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if any there are handlers registered. Debugging helper, should only be used for debugging and not relied on.</p>
<dl class="section return"><dt>Returns</dt><dd>true if there are, false if there are no registered handlers. </dd></dl>

</div>
</div>
<a id="aa0fa06b9b1b27f9b12f65f0fc2f3a847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fa06b9b1b27f9b12f65f0fc2f3a847">&#9670;&nbsp;</a></span>make_client()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Serializer , typename MsgType &gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseastar_1_1rpc_1_1protocol.html">seastar::rpc::protocol</a>&lt; Serializer, MsgType &gt;::make_client </td>
          <td>(</td>
          <td class="paramtype">MsgType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a callable that can be used to invoke the verb on the remote.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>The signature of the verb. Has to be either the same or compatible with the one passed to register_handler on the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the verb to invoke on the remote.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a callable whose signature is derived from Func as follows: given <code>Func == Ret(Args...)</code> the returned callable has the following signature: <code>future&lt;Ret&gt;(<a class="el" href="classseastar_1_1rpc_1_1protocol_1_1client.html" title="Represents a client side connection.">protocol::client</a>&amp;, Args...)</code>. </dd></dl>

</div>
</div>
<a id="ae72396a036b321136ffb0b9d85a3ccff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72396a036b321136ffb0b9d85a3ccff">&#9670;&nbsp;</a></span>register_handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Serializer , typename MsgType &gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseastar_1_1rpc_1_1protocol.html">seastar::rpc::protocol</a>&lt; Serializer, MsgType &gt;::register_handler </td>
          <td>(</td>
          <td class="paramtype">MsgType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a handler to be called when this verb is invoked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>the type of the handler for the verb. This determines the signature of the verb. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the verb to register the handler for. </td></tr>
    <tr><td class="paramname">func</td><td>the callable to be called when the verb is invoked by the remote.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a client, a callable that can be used to invoke the verb. See <a class="el" href="classseastar_1_1rpc_1_1protocol.html#aa0fa06b9b1b27f9b12f65f0fc2f3a847">make_client()</a>. The client can be discarded, in fact this is what most callers will do as real clients will live on a remote node, not on the one where handlers are registered. </dd></dl>

</div>
</div>
<a id="a77fbb6597b5ad698be3f2e42f5499c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fbb6597b5ad698be3f2e42f5499c69">&#9670;&nbsp;</a></span>register_handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Serializer , typename MsgType &gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseastar_1_1rpc_1_1protocol.html">seastar::rpc::protocol</a>&lt; Serializer, MsgType &gt;::register_handler </td>
          <td>(</td>
          <td class="paramtype">MsgType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseastar_1_1scheduling__group.html">scheduling_group</a>&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a handler to be called when this verb is invoked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>the type of the handler for the verb. This determines the signature of the verb. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the verb to register the handler for. </td></tr>
    <tr><td class="paramname">sg</td><td>the scheduling group that will be used to invoke the handler in. This can be used to execute different verbs in different scheduling groups. Note that there is a newer mechanism to determine the scheduling groups a handler will run it per invocation, see <a class="el" href="group__rpc.html#structseastar_1_1rpc_1_1isolation__config" title="Specifies resource isolation for a connection.">isolation_config</a>. </td></tr>
    <tr><td class="paramname">func</td><td>the callable to be called when the verb is invoked by the remote.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a client, a callable that can be used to invoke the verb. See <a class="el" href="classseastar_1_1rpc_1_1protocol.html#aa0fa06b9b1b27f9b12f65f0fc2f3a847">make_client()</a>. The client can be discarded, in fact this is what most callers will do as real clients will live on a remote node, not on the one where handlers are registered. </dd></dl>

</div>
</div>
<a id="a1080ac03247263174a9b3b3c605f19d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1080ac03247263174a9b3b3c605f19d1">&#9670;&nbsp;</a></span>set_logger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Serializer , typename MsgType  = uint32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseastar_1_1rpc_1_1protocol.html">seastar::rpc::protocol</a>&lt; Serializer, MsgType &gt;::set_logger </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const sstring &amp;)&gt;&#160;</td>
          <td class="paramname"><em>logger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a logger function to be used to log messages.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>use the logger overload <a class="el" href="classseastar_1_1rpc_1_1protocol.html#aa1ac72d6fa744b57b2aead4245058207" title="Set a logger to be used to log messages.">set_logger(::seastar::logger*)</a> instead. </dd></dl>

</div>
</div>
<a id="aea92d1b5ddbf34c72a46e9cb17eff5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea92d1b5ddbf34c72a46e9cb17eff5fe">&#9670;&nbsp;</a></span>unregister_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Serializer , typename MsgType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> <a class="el" href="classseastar_1_1rpc_1_1protocol.html">seastar::rpc::protocol</a>&lt; Serializer, MsgType &gt;::unregister_handler </td>
          <td>(</td>
          <td class="paramtype">MsgType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister the handler for the verb.</p>
<p>Waits for all currently running handlers, then unregisters the handler. Future attempts to invoke the verb will fail. This becomes effective immediately after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the verb to unregister the handler for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that becomes available once all currently running handlers finished. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seastar/rpc/<a class="el" href="rpc_8hh_source.html">rpc.hh</a></li>
<li>seastar/rpc/<a class="el" href="rpc__impl_8hh_source.html">rpc_impl.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
