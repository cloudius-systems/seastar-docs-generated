<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Seastar: seastar::coroutine::without_preemption_check&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Seastar
   </div>
   <div id="projectbrief">High performance C++ framework for concurrent servers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceseastar.html">seastar</a></li><li class="navelem"><b>coroutine</b></li><li class="navelem"><a class="el" href="structseastar_1_1coroutine_1_1without__preemption__check.html">without_preemption_check</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structseastar_1_1coroutine_1_1without__preemption__check-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seastar::coroutine::without_preemption_check&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename... T&gt;<br />
struct seastar::coroutine::without_preemption_check&lt; T &gt;</h3>

<p>Wrapper for a future which turns off checking for preemption when awaiting it in a coroutine. If constructed from a future, co_await-ing it will bypass checking if the task quota is depleted, which means that a ready future will be handled immediately. </p>
</div>
<p><code>#include &lt;<a class="el" href="coroutine_8hh_source.html">seastar/core/coroutine.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for seastar::coroutine::without_preemption_check&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structseastar_1_1coroutine_1_1without__preemption__check.png" usemap="#seastar::coroutine::without_5Fpreemption_5Fcheck_3C_20T_20_3E_map" alt=""/>
  <map id="seastar::coroutine::without_5Fpreemption_5Fcheck_3C_20T_20_3E_map" name="seastar::coroutine::without_5Fpreemption_5Fcheck_3C_20T_20_3E_map">
<area href="classseastar_1_1future.html" alt="seastar::future&lt; T... &gt;" shape="rect" coords="0,56,298,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a221dfd624fc12b0d5f8b58af000d7830"><td class="memItemLeft" align="right" valign="top"><a id="a221dfd624fc12b0d5f8b58af000d7830"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a221dfd624fc12b0d5f8b58af000d7830">value_type</a> = internal::future_stored_type_t&lt; T... &gt;</td></tr>
<tr class="memdesc:a221dfd624fc12b0d5f8b58af000d7830"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type carried by the future. <br /></td></tr>
<tr class="separator:a221dfd624fc12b0d5f8b58af000d7830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26495ab96137c2dd41e88830f2f8b8"><td class="memItemLeft" align="right" valign="top"><a id="a1a26495ab96137c2dd41e88830f2f8b8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tuple_type</b> = internal::future_tuple_type_t&lt; <a class="el" href="classseastar_1_1future.html#a221dfd624fc12b0d5f8b58af000d7830">value_type</a> &gt;</td></tr>
<tr class="separator:a1a26495ab96137c2dd41e88830f2f8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc1887a65ad82910d792219c9531ea6"><td class="memItemLeft" align="right" valign="top"><a id="afcc1887a65ad82910d792219c9531ea6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#afcc1887a65ad82910d792219c9531ea6">promise_type</a> = <a class="el" href="classseastar_1_1promise.html">promise</a>&lt; T... &gt;</td></tr>
<tr class="memdesc:afcc1887a65ad82910d792219c9531ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type carried by the future. <br /></td></tr>
<tr class="separator:afcc1887a65ad82910d792219c9531ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cf6847252d419e5241b0efc851e7e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a76cf6847252d419e5241b0efc851e7e2">get0_return_type</a> = typename future_state::get0_return_type</td></tr>
<tr class="separator:a76cf6847252d419e5241b0efc851e7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0aea8d029a9cd23987e5a0ab360bfa0"><td class="memItemLeft" align="right" valign="top"><a id="af0aea8d029a9cd23987e5a0ab360bfa0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>without_preemption_check</b> (<a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T... &gt; &amp;&amp;f) noexcept</td></tr>
<tr class="separator:af0aea8d029a9cd23987e5a0ab360bfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b727e7195750cec87028ee55629c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html#a221dfd624fc12b0d5f8b58af000d7830">value_type</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#ac9b727e7195750cec87028ee55629c93">get</a> ()</td></tr>
<tr class="memdesc:ac9b727e7195750cec87028ee55629c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the value returned by the computation  <a href="classseastar_1_1future.html#ac9b727e7195750cec87028ee55629c93">More...</a><br /></td></tr>
<tr class="separator:ac9b727e7195750cec87028ee55629c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c84f0caf7de8077ce959f9d6c1ad00"><td class="memItemLeft" align="right" valign="top"><a id="a34c84f0caf7de8077ce959f9d6c1ad00"></a>
std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>get_exception</b> () noexcept</td></tr>
<tr class="separator:a34c84f0caf7de8077ce959f9d6c1ad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4c39fa9349c733211d20df94250d2c"><td class="memItemLeft" align="right" valign="top"><a id="a1d4c39fa9349c733211d20df94250d2c"></a>
<a class="el" href="classseastar_1_1future.html#a76cf6847252d419e5241b0efc851e7e2">get0_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get0</b> ()</td></tr>
<tr class="separator:a1d4c39fa9349c733211d20df94250d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205a73ce01247cd7a8995569dedf78b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a205a73ce01247cd7a8995569dedf78b1">wait</a> () noexcept</td></tr>
<tr class="separator:a205a73ce01247cd7a8995569dedf78b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624fbb42c55d649348e47afba3de5ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a624fbb42c55d649348e47afba3de5ac3">available</a> () const noexcept</td></tr>
<tr class="memdesc:a624fbb42c55d649348e47afba3de5ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the future is available.  <a href="classseastar_1_1future.html#a624fbb42c55d649348e47afba3de5ac3">More...</a><br /></td></tr>
<tr class="separator:a624fbb42c55d649348e47afba3de5ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a82ea2b06f018fa8fbf6a45511ffa72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a5a82ea2b06f018fa8fbf6a45511ffa72">failed</a> () const noexcept</td></tr>
<tr class="memdesc:a5a82ea2b06f018fa8fbf6a45511ffa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the future has failed.  <a href="classseastar_1_1future.html#a5a82ea2b06f018fa8fbf6a45511ffa72">More...</a><br /></td></tr>
<tr class="separator:a5a82ea2b06f018fa8fbf6a45511ffa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4108dca2eb7bfd11fc45d6d6dda586c8"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8">then</a> (Func &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:a4108dca2eb7bfd11fc45d6d6dda586c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a block of code to run when the future is ready.  <a href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8">More...</a><br /></td></tr>
<tr class="separator:a4108dca2eb7bfd11fc45d6d6dda586c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab900c012feb51c76c1b5490d391e873f"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#ab900c012feb51c76c1b5490d391e873f">then_unpack</a> (Func &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:ab900c012feb51c76c1b5490d391e873f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a block of code to run when the future is ready, unpacking tuples.  <a href="classseastar_1_1future.html#ab900c012feb51c76c1b5490d391e873f">More...</a><br /></td></tr>
<tr class="separator:ab900c012feb51c76c1b5490d391e873f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972ade485986fb535c0a0ba258110749"><td class="memItemLeft" align="right" valign="top">futurize_t&lt; FuncResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a972ade485986fb535c0a0ba258110749">then_wrapped</a> (Func &amp;&amp;func) &amp;noexcept</td></tr>
<tr class="memdesc:a972ade485986fb535c0a0ba258110749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a block of code to run when the future is ready, allowing for exception handling.  <a href="classseastar_1_1future.html#a972ade485986fb535c0a0ba258110749">More...</a><br /></td></tr>
<tr class="separator:a972ade485986fb535c0a0ba258110749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d33f9149a337c1fc1267705c6fa5ddd"><td class="memItemLeft" align="right" valign="top"><a id="a7d33f9149a337c1fc1267705c6fa5ddd"></a>
futurize_t&lt; FuncResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>then_wrapped</b> (Func &amp;&amp;func) &amp;&amp;noexcept</td></tr>
<tr class="separator:a7d33f9149a337c1fc1267705c6fa5ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939d1f4da42f5c21715ce3d9382defc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a939d1f4da42f5c21715ce3d9382defc5">forward_to</a> (<a class="el" href="classseastar_1_1promise.html">promise</a>&lt; T... &gt; &amp;&amp;pr) noexcept</td></tr>
<tr class="memdesc:a939d1f4da42f5c21715ce3d9382defc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Satisfy some promise object with this future as a result.  <a href="classseastar_1_1future.html#a939d1f4da42f5c21715ce3d9382defc5">More...</a><br /></td></tr>
<tr class="separator:a939d1f4da42f5c21715ce3d9382defc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66babffa8a6fb89a4037b6b9a665a2d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; T... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#a66babffa8a6fb89a4037b6b9a665a2d9">finally</a> (Func &amp;&amp;func) noexcept</td></tr>
<tr class="separator:a66babffa8a6fb89a4037b6b9a665a2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89c68b8e980afd9a381c229b986086c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#ae89c68b8e980afd9a381c229b986086c">or_terminate</a> () noexcept</td></tr>
<tr class="memdesc:ae89c68b8e980afd9a381c229b986086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the program if this future fails.  <a href="classseastar_1_1future.html#ae89c68b8e980afd9a381c229b986086c">More...</a><br /></td></tr>
<tr class="separator:ae89c68b8e980afd9a381c229b986086c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a82e541cc18efbdb0903924276e9be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#ae4a82e541cc18efbdb0903924276e9be">discard_result</a> () noexcept</td></tr>
<tr class="memdesc:ae4a82e541cc18efbdb0903924276e9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards the value carried by this future.  <a href="classseastar_1_1future.html#ae4a82e541cc18efbdb0903924276e9be">More...</a><br /></td></tr>
<tr class="separator:ae4a82e541cc18efbdb0903924276e9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddd4b245179d5c93291f6e02479d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; T... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#addddd4b245179d5c93291f6e02479d83">handle_exception</a> (Func &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:addddd4b245179d5c93291f6e02479d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the exception carried by this future.  <a href="classseastar_1_1future.html#addddd4b245179d5c93291f6e02479d83">More...</a><br /></td></tr>
<tr class="separator:addddd4b245179d5c93291f6e02479d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb416c6313ba9925357ee68a71376135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; T... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#adb416c6313ba9925357ee68a71376135">handle_exception_type</a> (Func &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:adb416c6313ba9925357ee68a71376135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the exception of a certain type carried by this future.  <a href="classseastar_1_1future.html#adb416c6313ba9925357ee68a71376135">More...</a><br /></td></tr>
<tr class="separator:adb416c6313ba9925357ee68a71376135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25110829fc2dfc1d21e7d153743f416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1future.html#af25110829fc2dfc1d21e7d153743f416">ignore_ready_future</a> () noexcept</td></tr>
<tr class="memdesc:af25110829fc2dfc1d21e7d153743f416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore any result hold by this future.  <a href="classseastar_1_1future.html#af25110829fc2dfc1d21e7d153743f416">More...</a><br /></td></tr>
<tr class="separator:af25110829fc2dfc1d21e7d153743f416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a76cf6847252d419e5241b0efc851e7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cf6847252d419e5241b0efc851e7e2">&#9670;&nbsp;</a></span>get0_return_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::<a class="el" href="classseastar_1_1future.html#a76cf6847252d419e5241b0efc851e7e2">get0_return_type</a> =  typename future_state::get0_return_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the value returned by the computation.</p>
<p>Similar to <a class="el" href="classseastar_1_1future.html#ac9b727e7195750cec87028ee55629c93">get()</a>, but instead of returning a tuple, returns the first value of the tuple. This is useful for the common case of a <code>future&lt;T&gt;</code> with exactly one type parameter.</p>
<p>Equivalent to: <code>std::get&lt;0&gt;</code>(f.get()). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a624fbb42c55d649348e47afba3de5ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624fbb42c55d649348e47afba3de5ac3">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the future is available. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the future has a value, or has failed. </dd></dl>

</div>
</div>
<a id="ae4a82e541cc18efbdb0903924276e9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a82e541cc18efbdb0903924276e9be">&#9670;&nbsp;</a></span>discard_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::discard_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards the value carried by this future. </p>
<p>Converts the future into a no-value <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code>, by ignoring any result. Exceptions are propagated unchanged. </p>

</div>
</div>
<a id="a5a82ea2b06f018fa8fbf6a45511ffa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a82ea2b06f018fa8fbf6a45511ffa72">&#9670;&nbsp;</a></span>failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::failed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the future has failed. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the future is availble and has failed. </dd></dl>

</div>
</div>
<a id="a66babffa8a6fb89a4037b6b9a665a2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66babffa8a6fb89a4037b6b9a665a2d9">&#9670;&nbsp;</a></span>finally()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;T... &gt; <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::finally </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finally continuation for statements that require waiting for the result. I.e. you need to "finally" call a function that returns a possibly unavailable future. The returned future will be "waited for", any exception generated will be propagated, but the return value is ignored. I.e. the original return value (the future upon which you are making this call) will be preserved.</p>
<p>If the original return value or the callback return value is an exceptional future it will be propagated.</p>
<p>If both of them are exceptional - the std::nested_exception exception with the callback exception on top and the original future exception nested will be propagated. </p>

</div>
</div>
<a id="a939d1f4da42f5c21715ce3d9382defc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939d1f4da42f5c21715ce3d9382defc5">&#9670;&nbsp;</a></span>forward_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::forward_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseastar_1_1promise.html">promise</a>&lt; T...  &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>pr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Satisfy some <a class="el" href="classseastar_1_1promise.html">promise</a> object with this future as a result. </p>
<p>Arranges so that when this future is resolve, it will be used to satisfy an unrelated promise. This is similar to scheduling a continuation that moves the result of this future into the promise (using <a class="el" href="classseastar_1_1promise.html#a8c9a385f90d5b351fc171583fc3fb425" title="Sets the promises value.">promise::set_value()</a> or <a class="el" href="classseastar_1_1promise.html#acb9650b8cab53c81184d0b170bb99cb8" title="Marks the promise as failed.">promise::set_exception()</a>, except that it is more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pr</td><td>a promise that will be fulfilled with the results of this future. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9b727e7195750cec87028ee55629c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b727e7195750cec87028ee55629c93">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html#a221dfd624fc12b0d5f8b58af000d7830">value_type</a>&amp;&amp; <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets the value returned by the computation </p>
<p>Requires that the future be available. If the value was computed successfully, it is returned (as an <code>std::tuple</code>). Otherwise, an exception is thrown.</p>
<p>If <a class="el" href="classseastar_1_1future.html#ac9b727e7195750cec87028ee55629c93" title="gets the value returned by the computation">get()</a> is called in a <a class="el" href="classseastar_1_1thread.html">seastar::thread</a> context, then it need not be available; instead, the thread will be paused until the future becomes available. </p>

</div>
</div>
<a id="addddd4b245179d5c93291f6e02479d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addddd4b245179d5c93291f6e02479d83">&#9670;&nbsp;</a></span>handle_exception()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;T... &gt; <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::handle_exception </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the exception carried by this future. </p>
<p>When the future resolves, if it resolves with an exception, handle_exception(func) replaces the exception with the value returned by func. The exception is passed (as a std::exception_ptr) as a parameter to func; func may return the replacement value immediately (T or std::tuple&lt;T...&gt;) or in the future (<a class="el" href="classseastar_1_1future.html">future&lt;T...&gt;</a>) and is even allowed to return (or throw) its own exception.</p>
<p>The idiom fut.discard_result().handle_exception(...) can be used to handle an exception (if there is one) without caring about the successful value; Because <a class="el" href="classseastar_1_1future.html#addddd4b245179d5c93291f6e02479d83" title="Handle the exception carried by this future.">handle_exception()</a> is used here on a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a>, the handler function does not need to return anything. </p>

</div>
</div>
<a id="adb416c6313ba9925357ee68a71376135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb416c6313ba9925357ee68a71376135">&#9670;&nbsp;</a></span>handle_exception_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;T... &gt; <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::handle_exception_type </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the exception of a certain type carried by this future. </p>
<p>When the future resolves, if it resolves with an exception of a type that provided callback receives as a parameter, <code>handle_exception_type(func)</code> replaces the exception with the value returned by func. The exception is passed (by reference) as a parameter to func; func may return the replacement value immediately (T or std::tuple&lt;T...&gt;) or in the future (<a class="el" href="classseastar_1_1future.html">future&lt;T...&gt;</a>) and is even allowed to return (or throw) its own exception. If exception, that future holds, does not match func parameter type it is propagated as is. </p>

</div>
</div>
<a id="af25110829fc2dfc1d21e7d153743f416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25110829fc2dfc1d21e7d153743f416">&#9670;&nbsp;</a></span>ignore_ready_future()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::ignore_ready_future </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ignore any result hold by this future. </p>
<p>Ignore any result (value or exception) hold by this future. Use with caution since usually ignoring exception is not what you want </p>

</div>
</div>
<a id="ae89c68b8e980afd9a381c229b986086c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89c68b8e980afd9a381c229b986086c">&#9670;&nbsp;</a></span>or_terminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::or_terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminate the program if this future fails. </p>
<p>Terminates the entire program is this future resolves to an exception. Use with caution. </p>

</div>
</div>
<a id="a4108dca2eb7bfd11fc45d6d6dda586c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4108dca2eb7bfd11fc45d6d6dda586c8">&#9670;&nbsp;</a></span>then()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::then </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule a block of code to run when the future is ready. </p>
<p>Schedules a function (often a lambda) to run when the future becomes available. The function is called with the result of this future's computation as parameters. The return value of the function becomes the return value of <a class="el" href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8" title="Schedule a block of code to run when the future is ready.">then()</a>, itself as a future; this allows <a class="el" href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8" title="Schedule a block of code to run when the future is ready.">then()</a> calls to be chained.</p>
<p>If the future failed, the function is not called, and the exception is propagated into the return value of <a class="el" href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8" title="Schedule a block of code to run when the future is ready.">then()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>- function to be called when the future becomes available, unless it has failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>future</code> representing the return value of <code>func</code>, applied to the eventual value of this future. </dd></dl>

</div>
</div>
<a id="ab900c012feb51c76c1b5490d391e873f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab900c012feb51c76c1b5490d391e873f">&#9670;&nbsp;</a></span>then_unpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::then_unpack </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule a block of code to run when the future is ready, unpacking tuples. </p>
<p>Schedules a function (often a lambda) to run when the future becomes available. The function is called with the result of this future's computation as parameters. The return value of the function becomes the return value of <a class="el" href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8" title="Schedule a block of code to run when the future is ready.">then()</a>, itself as a future; this allows <a class="el" href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8" title="Schedule a block of code to run when the future is ready.">then()</a> calls to be chained.</p>
<p>This member function is only available when the payload is std::tuple; The tuple elements are passed as individual arguments to <code>func</code>, which must have the same arity as the tuple.</p>
<p>If the future failed, the function is not called, and the exception is propagated into the return value of <a class="el" href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8" title="Schedule a block of code to run when the future is ready.">then()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>- function to be called when the future becomes available, unless it has failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>future</code> representing the return value of <code>func</code>, applied to the eventual value of this future. </dd></dl>

</div>
</div>
<a id="a972ade485986fb535c0a0ba258110749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972ade485986fb535c0a0ba258110749">&#9670;&nbsp;</a></span>then_wrapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">futurize_t&lt;FuncResult&gt; <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::then_wrapped </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule a block of code to run when the future is ready, allowing for exception handling. </p>
<p>Schedules a function (often a lambda) to run when the future becomes available. The function is called with the this future as a parameter; it will be in an available state. The return value of the function becomes the return value of <a class="el" href="classseastar_1_1future.html#a972ade485986fb535c0a0ba258110749" title="Schedule a block of code to run when the future is ready, allowing for exception handling.">then_wrapped()</a>, itself as a future; this allows <a class="el" href="classseastar_1_1future.html#a972ade485986fb535c0a0ba258110749" title="Schedule a block of code to run when the future is ready, allowing for exception handling.">then_wrapped()</a> calls to be chained.</p>
<p>Unlike <a class="el" href="classseastar_1_1future.html#a4108dca2eb7bfd11fc45d6d6dda586c8" title="Schedule a block of code to run when the future is ready.">then()</a>, the function will be called for both value and exceptional futures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>- function to be called when the future becomes available, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>future</code> representing the return value of <code>func</code>, applied to the eventual value of this future. </dd></dl>

</div>
</div>
<a id="a205a73ce01247cd7a8995569dedf78b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205a73ce01247cd7a8995569dedf78b1">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseastar_1_1future.html">seastar::future</a>&lt; T...  &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for the future to be available (in a <a class="el" href="classseastar_1_1thread.html" title="thread - stateful thread of execution">seastar::thread</a>)</p>
<p>When called from a <a class="el" href="classseastar_1_1thread.html" title="thread - stateful thread of execution">seastar::thread</a>, this function blocks the thread until the future is availble. Other threads and continuations continue to execute; only the thread is blocked. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>seastar/core/<a class="el" href="coroutine_8hh_source.html">coroutine.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
