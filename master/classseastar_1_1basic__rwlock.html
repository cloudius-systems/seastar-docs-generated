<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Seastar: seastar::basic_rwlock&lt; Clock &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Seastar
   </div>
   <div id="projectbrief">High performance C++ framework for concurrent servers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceseastar.html">seastar</a></li><li class="navelem"><a class="el" href="classseastar_1_1basic__rwlock.html">basic_rwlock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseastar_1_1basic__rwlock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seastar::basic_rwlock&lt; Clock &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__fiber-module.html">Fibers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Clock = typename timer&lt;&gt;::clock&gt;<br />
class seastar::basic_rwlock&lt; Clock &gt;</h3>

<p>Implements a read-write lock mechanism. Beware: this is not a cross-CPU lock, due to seastar's sharded architecture. Instead, it can be used to achieve rwlock semantics between two (or more) fibers running in the same CPU that may use the same resource. Acquiring the write lock will effectively cause all readers not to be executed until the write part is done. </p>
</div>
<p><code>#include &lt;<a class="el" href="rwlock_8hh_source.html">seastar/core/rwlock.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for seastar::basic_rwlock&lt; Clock &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classseastar_1_1basic__rwlock.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a806718cf50fe1b9dd9ad27f6b43267ca"><td class="memItemLeft" align="right" valign="top"><a id="a806718cf50fe1b9dd9ad27f6b43267ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>holder</b> = <a class="el" href="classseastar_1_1semaphore__units.html">semaphore_units</a>&lt; <a class="el" href="structseastar_1_1semaphore__default__exception__factory.html">semaphore_default_exception_factory</a>, Clock &gt;</td></tr>
<tr class="separator:a806718cf50fe1b9dd9ad27f6b43267ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1113ccb62b06272f7ca9f66c835a58c1"><td class="memItemLeft" align="right" valign="top">rwlock_for_read&lt; Clock &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#a1113ccb62b06272f7ca9f66c835a58c1">for_read</a> ()</td></tr>
<tr class="separator:a1113ccb62b06272f7ca9f66c835a58c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4babd10bffd7fc4bd8acc9399e931d8"><td class="memItemLeft" align="right" valign="top">rwlock_for_write&lt; Clock &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#ad4babd10bffd7fc4bd8acc9399e931d8">for_write</a> ()</td></tr>
<tr class="separator:ad4babd10bffd7fc4bd8acc9399e931d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0231bd4641b247f5cb8d1b9f1641bc6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#a0231bd4641b247f5cb8d1b9f1641bc6f">read_lock</a> (typename semaphore_type::time_point timeout=semaphore_type::time_point::max())</td></tr>
<tr class="separator:a0231bd4641b247f5cb8d1b9f1641bc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6914598019908126accf79b2c41ccfb1"><td class="memItemLeft" align="right" valign="top"><a id="a6914598019908126accf79b2c41ccfb1"></a>
<a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_lock</b> (<a class="el" href="classseastar_1_1abort__source.html">abort_source</a> &amp;as)</td></tr>
<tr class="separator:a6914598019908126accf79b2c41ccfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b280f46f5ab0104c4017512c46b2f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#a0b280f46f5ab0104c4017512c46b2f0d">read_unlock</a> ()</td></tr>
<tr class="separator:a0b280f46f5ab0104c4017512c46b2f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4398bb9b96ba08197aba88eba8e0d09d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#a4398bb9b96ba08197aba88eba8e0d09d">write_lock</a> (typename semaphore_type::time_point timeout=semaphore_type::time_point::max())</td></tr>
<tr class="separator:a4398bb9b96ba08197aba88eba8e0d09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6598dab951a0ff0847c48fa260fbb95d"><td class="memItemLeft" align="right" valign="top"><a id="a6598dab951a0ff0847c48fa260fbb95d"></a>
<a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><b>write_lock</b> (<a class="el" href="classseastar_1_1abort__source.html">abort_source</a> &amp;as)</td></tr>
<tr class="separator:a6598dab951a0ff0847c48fa260fbb95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff43c7129ab24a675b5898368870119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#afff43c7129ab24a675b5898368870119">write_unlock</a> ()</td></tr>
<tr class="separator:afff43c7129ab24a675b5898368870119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61020fcba43c56baab9db66ad9d34ab7"><td class="memItemLeft" align="right" valign="top"><a id="a61020fcba43c56baab9db66ad9d34ab7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#a61020fcba43c56baab9db66ad9d34ab7">try_read_lock</a> ()</td></tr>
<tr class="memdesc:a61020fcba43c56baab9db66ad9d34ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire the lock in read mode iff this can be done without waiting. <br /></td></tr>
<tr class="separator:a61020fcba43c56baab9db66ad9d34ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83165946f4cd04894dcebae75e128dd7"><td class="memItemLeft" align="right" valign="top"><a id="a83165946f4cd04894dcebae75e128dd7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#a83165946f4cd04894dcebae75e128dd7">try_write_lock</a> ()</td></tr>
<tr class="memdesc:a83165946f4cd04894dcebae75e128dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire the lock in write mode iff this can be done without waiting. <br /></td></tr>
<tr class="separator:a83165946f4cd04894dcebae75e128dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa65d4eafc80ae40befe9a22c1e8ed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; <a class="el" href="classseastar_1_1semaphore__units.html">holder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#abfa65d4eafc80ae40befe9a22c1e8ed9">hold_read_lock</a> (typename semaphore_type::time_point timeout=semaphore_type::time_point::max())</td></tr>
<tr class="separator:abfa65d4eafc80ae40befe9a22c1e8ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f8e3b7e848790a85aef4ed0f47042a"><td class="memItemLeft" align="right" valign="top"><a id="ad7f8e3b7e848790a85aef4ed0f47042a"></a>
<a class="el" href="classseastar_1_1future.html">future</a>&lt; <a class="el" href="classseastar_1_1semaphore__units.html">holder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hold_read_lock</b> (<a class="el" href="classseastar_1_1abort__source.html">abort_source</a> &amp;as)</td></tr>
<tr class="separator:ad7f8e3b7e848790a85aef4ed0f47042a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3653681b760438dfb163788b5755cbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; <a class="el" href="classseastar_1_1semaphore__units.html">holder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#a3653681b760438dfb163788b5755cbb0">hold_write_lock</a> (typename semaphore_type::time_point timeout=semaphore_type::time_point::max())</td></tr>
<tr class="separator:a3653681b760438dfb163788b5755cbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d84ae544173fdd75ea32585a91a9ff9"><td class="memItemLeft" align="right" valign="top"><a id="a0d84ae544173fdd75ea32585a91a9ff9"></a>
<a class="el" href="classseastar_1_1future.html">future</a>&lt; <a class="el" href="classseastar_1_1semaphore__units.html">holder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hold_write_lock</b> (<a class="el" href="classseastar_1_1abort__source.html">abort_source</a> &amp;as)</td></tr>
<tr class="separator:a0d84ae544173fdd75ea32585a91a9ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3e135f9983ef093c27d6ba2517a1e8"><td class="memItemLeft" align="right" valign="top"><a id="abf3e135f9983ef093c27d6ba2517a1e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1basic__rwlock.html#abf3e135f9983ef093c27d6ba2517a1e8">locked</a> () const</td></tr>
<tr class="memdesc:abf3e135f9983ef093c27d6ba2517a1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any read or write locks are currently held. <br /></td></tr>
<tr class="separator:abf3e135f9983ef093c27d6ba2517a1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1113ccb62b06272f7ca9f66c835a58c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1113ccb62b06272f7ca9f66c835a58c1">&#9670;&nbsp;</a></span>for_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock  = typename timer&lt;&gt;::clock&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rwlock_for_read&lt;Clock&gt;&amp; <a class="el" href="classseastar_1_1basic__rwlock.html">seastar::basic_rwlock</a>&lt; Clock &gt;::for_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this rwlock into read lock object with lock semantics appropriate to be used by "with_lock". The resulting object will have lock / unlock calls that, when called, will acquire / release the lock in read mode. </p>

</div>
</div>
<a id="ad4babd10bffd7fc4bd8acc9399e931d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4babd10bffd7fc4bd8acc9399e931d8">&#9670;&nbsp;</a></span>for_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock  = typename timer&lt;&gt;::clock&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rwlock_for_write&lt;Clock&gt;&amp; <a class="el" href="classseastar_1_1basic__rwlock.html">seastar::basic_rwlock</a>&lt; Clock &gt;::for_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this rwlock into write lock object with lock semantics appropriate to be used by "with_lock". The resulting object will have lock / unlock calls that, when called, will acquire / release the lock in write mode. </p>

</div>
</div>
<a id="abfa65d4eafc80ae40befe9a22c1e8ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa65d4eafc80ae40befe9a22c1e8ed9">&#9670;&nbsp;</a></span>hold_read_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock  = typename timer&lt;&gt;::clock&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;<a class="el" href="classseastar_1_1semaphore__units.html">holder</a>&gt; <a class="el" href="classseastar_1_1basic__rwlock.html">seastar::basic_rwlock</a>&lt; Clock &gt;::hold_read_lock </td>
          <td>(</td>
          <td class="paramtype">typename semaphore_type::time_point&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>semaphore_type::time_point::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classseastar_1_1basic__rwlock.html#abfa65d4eafc80ae40befe9a22c1e8ed9">hold_read_lock()</a> waits for a read lock and returns an object which, when destroyed, releases the lock. This makes it easy to ensure that the lock is eventually undone, at any circumstance (even including exceptions). The release() method can be used on the returned object to release its ownership of the lock and avoid the automatic unlock. Note that both <a class="el" href="classseastar_1_1basic__rwlock.html#abfa65d4eafc80ae40befe9a22c1e8ed9">hold_read_lock()</a> and <a class="el" href="classseastar_1_1basic__rwlock.html#a3653681b760438dfb163788b5755cbb0">hold_write_lock()</a> return an object of the same type, rwlock::holder.</p>
<p><a class="el" href="classseastar_1_1basic__rwlock.html#abfa65d4eafc80ae40befe9a22c1e8ed9">hold_read_lock()</a> may throw an exception (or, in other implementations, return an exceptional future) when it failed to obtain the lock - e.g., on allocation failure. </p>

</div>
</div>
<a id="a3653681b760438dfb163788b5755cbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3653681b760438dfb163788b5755cbb0">&#9670;&nbsp;</a></span>hold_write_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock  = typename timer&lt;&gt;::clock&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;<a class="el" href="classseastar_1_1semaphore__units.html">holder</a>&gt; <a class="el" href="classseastar_1_1basic__rwlock.html">seastar::basic_rwlock</a>&lt; Clock &gt;::hold_write_lock </td>
          <td>(</td>
          <td class="paramtype">typename semaphore_type::time_point&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>semaphore_type::time_point::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classseastar_1_1basic__rwlock.html#a3653681b760438dfb163788b5755cbb0">hold_write_lock()</a> waits for a write lock and returns an object which, when destroyed, releases the lock. This makes it easy to ensure that the lock is eventually undone, at any circumstance (even including exceptions). The release() method can be used on the returned object to release its ownership of the lock and avoid the automatic unlock. Note that both <a class="el" href="classseastar_1_1basic__rwlock.html#abfa65d4eafc80ae40befe9a22c1e8ed9">hold_read_lock()</a> and <a class="el" href="classseastar_1_1basic__rwlock.html#a3653681b760438dfb163788b5755cbb0">hold_write_lock()</a> return an object of the same type, rwlock::holder.</p>
<p><a class="el" href="classseastar_1_1basic__rwlock.html#abfa65d4eafc80ae40befe9a22c1e8ed9">hold_read_lock()</a> may throw an exception (or, in other implementations, return an exceptional future) when it failed to obtain the lock - e.g., on allocation failure. </p>

</div>
</div>
<a id="a0231bd4641b247f5cb8d1b9f1641bc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0231bd4641b247f5cb8d1b9f1641bc6f">&#9670;&nbsp;</a></span>read_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock  = typename timer&lt;&gt;::clock&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> <a class="el" href="classseastar_1_1basic__rwlock.html">seastar::basic_rwlock</a>&lt; Clock &gt;::read_lock </td>
          <td>(</td>
          <td class="paramtype">typename semaphore_type::time_point&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>semaphore_type::time_point::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquires this lock in read mode. Many readers are allowed, but when this future returns, and until <a class="el" href="classseastar_1_1basic__rwlock.html#a0b280f46f5ab0104c4017512c46b2f0d">read_unlock</a> is called, all fibers waiting on <a class="el" href="classseastar_1_1basic__rwlock.html#a4398bb9b96ba08197aba88eba8e0d09d">write_lock</a> are guaranteed not to execute. </p>

</div>
</div>
<a id="a0b280f46f5ab0104c4017512c46b2f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b280f46f5ab0104c4017512c46b2f0d">&#9670;&nbsp;</a></span>read_unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock  = typename timer&lt;&gt;::clock&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseastar_1_1basic__rwlock.html">seastar::basic_rwlock</a>&lt; Clock &gt;::read_unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases the lock, which must have been taken in read mode. After this is called, one of the fibers waiting on <a class="el" href="classseastar_1_1basic__rwlock.html#a4398bb9b96ba08197aba88eba8e0d09d">write_lock</a> will be allowed to proceed. </p>

</div>
</div>
<a id="a4398bb9b96ba08197aba88eba8e0d09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4398bb9b96ba08197aba88eba8e0d09d">&#9670;&nbsp;</a></span>write_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock  = typename timer&lt;&gt;::clock&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> <a class="el" href="classseastar_1_1basic__rwlock.html">seastar::basic_rwlock</a>&lt; Clock &gt;::write_lock </td>
          <td>(</td>
          <td class="paramtype">typename semaphore_type::time_point&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>semaphore_type::time_point::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquires this lock in write mode. Only one writer is allowed. When this future returns, and until <a class="el" href="classseastar_1_1basic__rwlock.html#afff43c7129ab24a675b5898368870119">write_unlock</a> is called, all other fibers waiting on either <a class="el" href="classseastar_1_1basic__rwlock.html#a0231bd4641b247f5cb8d1b9f1641bc6f">read_lock</a> or <a class="el" href="classseastar_1_1basic__rwlock.html#a4398bb9b96ba08197aba88eba8e0d09d">write_lock</a> are guaranteed not to execute. </p>

</div>
</div>
<a id="afff43c7129ab24a675b5898368870119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff43c7129ab24a675b5898368870119">&#9670;&nbsp;</a></span>write_unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock  = typename timer&lt;&gt;::clock&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseastar_1_1basic__rwlock.html">seastar::basic_rwlock</a>&lt; Clock &gt;::write_unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases the lock, which must have been taken in write mode. After this is called, one of the other fibers waiting on <a class="el" href="classseastar_1_1basic__rwlock.html#a4398bb9b96ba08197aba88eba8e0d09d">write_lock</a> or the fibers waiting on <a class="el" href="classseastar_1_1basic__rwlock.html#a0231bd4641b247f5cb8d1b9f1641bc6f">read_lock</a> will be allowed to proceed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seastar/core/<a class="el" href="rwlock_8hh_source.html">rwlock.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
