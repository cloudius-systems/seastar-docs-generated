<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Seastar: Future Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Seastar
   </div>
   <div id="projectbrief">High performance C++ framework for concurrent servers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Future Utilities<div class="ingroups"><a class="el" href="group__future-module.html">Futures and Promises</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These utilities are provided to help perform operations on futures. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseastar_1_1is__future.html">seastar::is_future&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a type is a future.  <a href="structseastar_1_1is__future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseastar_1_1futurize.html">seastar::futurize&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a type to a future type, if it isn't already.  <a href="structseastar_1_1futurize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structseastar_1_1stop__iteration__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__future-util.html#structseastar_1_1stop__iteration__tag">seastar::stop_iteration_tag</a></td></tr>
<tr class="separator:structseastar_1_1stop__iteration__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1adder.html">seastar::adder&lt; Result, Addend &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga71564ac15104bf392093946a0e3f67f6"><td class="memTemplParams" colspan="2"><a id="ga71564ac15104bf392093946a0e3f67f6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga71564ac15104bf392093946a0e3f67f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seastar::futurize_t</b> = typename <a class="el" href="structseastar_1_1futurize.html">futurize</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ga71564ac15104bf392093946a0e3f67f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda7307a6ee79887791639ff4a963ea8"><td class="memItemLeft" align="right" valign="top"><a id="gacda7307a6ee79887791639ff4a963ea8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>seastar::stop_iteration</b> = <a class="el" href="classseastar_1_1bool__class.html">bool_class</a>&lt; <a class="el" href="group__future-util.html#structseastar_1_1stop__iteration__tag">stop_iteration_tag</a> &gt;</td></tr>
<tr class="separator:gacda7307a6ee79887791639ff4a963ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3983004a3a79b563b0609146d008ff6b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... More&gt; </td></tr>
<tr class="memitem:ga3983004a3a79b563b0609146d008ff6b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga3983004a3a79b563b0609146d008ff6b">seastar::do_with</a> (T1 &amp;&amp;rv1, T2 &amp;&amp;rv2, More &amp;&amp;... more) noexcept</td></tr>
<tr class="separator:ga3983004a3a79b563b0609146d008ff6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fd3e3a0e5ba88fc4aa236494c1d00b"><td class="memTemplParams" colspan="2">template&lt;typename Lock , typename Func &gt; </td></tr>
<tr class="memitem:gab8fd3e3a0e5ba88fc4aa236494c1d00b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#gab8fd3e3a0e5ba88fc4aa236494c1d00b">seastar::with_lock</a> (Lock &amp;lock, Func &amp;&amp;func)</td></tr>
<tr class="separator:gab8fd3e3a0e5ba88fc4aa236494c1d00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bda63f9f04605c540295f06e7a5e1db"><td class="memTemplParams" colspan="2"><a id="ga8bda63f9f04605c540295f06e7a5e1db"></a>
template&lt;typename AsyncAction &gt; </td></tr>
<tr class="memitem:ga8bda63f9f04605c540295f06e7a5e1db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seastar::repeat</b> (const AsyncAction &amp;action) noexcept=delete</td></tr>
<tr class="separator:ga8bda63f9f04605c540295f06e7a5e1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58948ec92bc558fda37e69ee7b44f20"><td class="memTemplParams" colspan="2"><a id="gad58948ec92bc558fda37e69ee7b44f20"></a>
template&lt;typename AsyncAction &gt; </td></tr>
<tr class="memitem:gad58948ec92bc558fda37e69ee7b44f20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seastar::repeat</b> (AsyncAction &amp;action) noexcept=delete</td></tr>
<tr class="separator:gad58948ec92bc558fda37e69ee7b44f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685902b4814947b091c3bed6535267d9"><td class="memTemplParams" colspan="2">template&lt;typename AsyncAction &gt; </td></tr>
<tr class="memitem:ga685902b4814947b091c3bed6535267d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga685902b4814947b091c3bed6535267d9">seastar::repeat</a> (AsyncAction &amp;&amp;action) noexcept</td></tr>
<tr class="separator:ga685902b4814947b091c3bed6535267d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ee1bd14b2fae297d9b81e409cfa99f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncAction &gt; </td></tr>
<tr class="memitem:ga99ee1bd14b2fae297d9b81e409cfa99f"><td class="memTemplItemLeft" align="right" valign="top">repeat_until_value_return_type&lt; AsyncAction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga99ee1bd14b2fae297d9b81e409cfa99f">seastar::repeat_until_value</a> (AsyncAction action) noexcept</td></tr>
<tr class="separator:ga99ee1bd14b2fae297d9b81e409cfa99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154305d8b7c89b320954885d6604f78e"><td class="memTemplParams" colspan="2">template&lt;typename AsyncAction , typename StopCondition &gt; </td></tr>
<tr class="memitem:ga154305d8b7c89b320954885d6604f78e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga154305d8b7c89b320954885d6604f78e">seastar::do_until</a> (StopCondition stop_cond, AsyncAction action) noexcept</td></tr>
<tr class="separator:ga154305d8b7c89b320954885d6604f78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga515b7f03a7b2a47c682da816e187f666"><td class="memTemplParams" colspan="2">template&lt;typename AsyncAction &gt; </td></tr>
<tr class="memitem:ga515b7f03a7b2a47c682da816e187f666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga515b7f03a7b2a47c682da816e187f666">seastar::keep_doing</a> (AsyncAction action) noexcept</td></tr>
<tr class="separator:ga515b7f03a7b2a47c682da816e187f666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0e0000a074e16222f443c5b157c4cd7"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename AsyncAction &gt; </td></tr>
<tr class="memitem:gab0e0000a074e16222f443c5b157c4cd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#gab0e0000a074e16222f443c5b157c4cd7">seastar::do_for_each</a> (Iterator begin, Iterator end, AsyncAction action) noexcept</td></tr>
<tr class="memdesc:gab0e0000a074e16222f443c5b157c4cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function for each item in a range, sequentially (iterator version).  <a href="group__future-util.html#gab0e0000a074e16222f443c5b157c4cd7">More...</a><br /></td></tr>
<tr class="separator:gab0e0000a074e16222f443c5b157c4cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24dcdd1f1d3413cd97863a0c87ace5c"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename AsyncAction &gt; </td></tr>
<tr class="memitem:gae24dcdd1f1d3413cd97863a0c87ace5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#gae24dcdd1f1d3413cd97863a0c87ace5c">seastar::do_for_each</a> (Container &amp;c, AsyncAction action) noexcept</td></tr>
<tr class="memdesc:gae24dcdd1f1d3413cd97863a0c87ace5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function for each item in a range, sequentially (range version).  <a href="group__future-util.html#gae24dcdd1f1d3413cd97863a0c87ace5c">More...</a><br /></td></tr>
<tr class="separator:gae24dcdd1f1d3413cd97863a0c87ace5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf687b5637cac1ef4c74c1d5344c86974"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Sentinel , typename Func &gt; </td></tr>
<tr class="memitem:gaf687b5637cac1ef4c74c1d5344c86974"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#gaf687b5637cac1ef4c74c1d5344c86974">seastar::parallel_for_each</a> (Iterator begin, Sentinel end, Func &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:gaf687b5637cac1ef4c74c1d5344c86974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run tasks in parallel (iterator version).  <a href="group__future-util.html#gaf687b5637cac1ef4c74c1d5344c86974">More...</a><br /></td></tr>
<tr class="separator:gaf687b5637cac1ef4c74c1d5344c86974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2082e40ac641ae5ede6f42665a74472"><td class="memTemplParams" colspan="2"><a id="gae2082e40ac641ae5ede6f42665a74472"></a>
template&lt;typename Range , typename Func &gt; </td></tr>
<tr class="memitem:gae2082e40ac641ae5ede6f42665a74472"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seastar::parallel_for_each</b> (Range &amp;&amp;range, Func &amp;&amp;func) noexcept</td></tr>
<tr class="separator:gae2082e40ac641ae5ede6f42665a74472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2681cbe7e3bc3fe21d5314644bedb474"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Sentinel , typename Func &gt; </td></tr>
<tr class="memitem:ga2681cbe7e3bc3fe21d5314644bedb474"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga2681cbe7e3bc3fe21d5314644bedb474">seastar::max_concurrent_for_each</a> (Iterator begin, Sentinel end, size_t max_concurrent, Func &amp;&amp;func) noexcept</td></tr>
<tr class="separator:ga2681cbe7e3bc3fe21d5314644bedb474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76b07053b6d78c646dff797b41ee912a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Func &gt; </td></tr>
<tr class="memitem:ga76b07053b6d78c646dff797b41ee912a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga76b07053b6d78c646dff797b41ee912a">seastar::max_concurrent_for_each</a> (Range &amp;&amp;range, size_t max_concurrent, Func &amp;&amp;func) noexcept</td></tr>
<tr class="separator:ga76b07053b6d78c646dff797b41ee912a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50a2c803cc55b3e75d8054bb5baf7fd"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Mapper , typename Reducer &gt; </td></tr>
<tr class="memitem:gaa50a2c803cc55b3e75d8054bb5baf7fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">seastar::map_reduce</a> (Iterator begin, Iterator end, Mapper &amp;&amp;mapper, Reducer &amp;&amp;r) -&gt; typename reducer_traits&lt; Reducer &gt;::future_type</td></tr>
<tr class="separator:gaa50a2c803cc55b3e75d8054bb5baf7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ad82a5fe5ca21bd9a4af17056fcfd8"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Mapper , typename Initial , typename Reduce &gt; </td></tr>
<tr class="memitem:ga60ad82a5fe5ca21bd9a4af17056fcfd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; Initial &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga60ad82a5fe5ca21bd9a4af17056fcfd8">seastar::map_reduce</a> (Iterator begin, Iterator end, Mapper &amp;&amp;mapper, Initial initial, Reduce reduce)</td></tr>
<tr class="separator:ga60ad82a5fe5ca21bd9a4af17056fcfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb7da1bed235de9fe71ec029aa42182"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Mapper , typename Initial , typename Reduce &gt; </td></tr>
<tr class="memitem:gadbb7da1bed235de9fe71ec029aa42182"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; Initial &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#gadbb7da1bed235de9fe71ec029aa42182">seastar::map_reduce</a> (Range &amp;&amp;range, Mapper &amp;&amp;mapper, Initial initial, Reduce reduce)</td></tr>
<tr class="separator:gadbb7da1bed235de9fe71ec029aa42182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64cf7dbb446c6618955e23959ee79401"><td class="memTemplParams" colspan="2">template&lt;typename... FutOrFuncs&gt; </td></tr>
<tr class="memitem:ga64cf7dbb446c6618955e23959ee79401"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga64cf7dbb446c6618955e23959ee79401">seastar::when_all</a> (FutOrFuncs &amp;&amp;... fut_or_funcs) noexcept</td></tr>
<tr class="separator:ga64cf7dbb446c6618955e23959ee79401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe73d5f5520c21fd438c65f1ea506557"><td class="memTemplParams" colspan="2">template&lt;typename FutureIterator &gt; </td></tr>
<tr class="memitem:gabe73d5f5520c21fd438c65f1ea506557"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; std::vector&lt; typename std::iterator_traits&lt; FutureIterator &gt;::value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#gabe73d5f5520c21fd438c65f1ea506557">seastar::when_all</a> (FutureIterator begin, FutureIterator end) noexcept</td></tr>
<tr class="separator:gabe73d5f5520c21fd438c65f1ea506557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38a94c0a3e1ed93ff40960f985565053"><td class="memTemplParams" colspan="2">template&lt;typename... FutOrFuncs&gt; </td></tr>
<tr class="memitem:ga38a94c0a3e1ed93ff40960f985565053"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga38a94c0a3e1ed93ff40960f985565053">seastar::when_all_succeed</a> (FutOrFuncs &amp;&amp;... fut_or_funcs) noexcept</td></tr>
<tr class="separator:ga38a94c0a3e1ed93ff40960f985565053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58711f44ded903f41611d1723bc0ee61"><td class="memTemplParams" colspan="2">template&lt;typename FutureIterator , typename  = typename std::iterator_traits&lt;FutureIterator&gt;::value_type&gt; </td></tr>
<tr class="memitem:ga58711f44ded903f41611d1723bc0ee61"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga58711f44ded903f41611d1723bc0ee61">seastar::when_all_succeed</a> (FutureIterator begin, FutureIterator end) noexcept</td></tr>
<tr class="separator:ga58711f44ded903f41611d1723bc0ee61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f32afb5e9ab48be779615692e88e588"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4f32afb5e9ab48be779615692e88e588"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga4f32afb5e9ab48be779615692e88e588">seastar::when_all_succeed</a> (std::vector&lt; <a class="el" href="classseastar_1_1future.html">future</a>&lt; T &gt;&gt; &amp;&amp;futures) noexcept</td></tr>
<tr class="separator:ga4f32afb5e9ab48be779615692e88e588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8243af4d7bdc89e99894ef6b310aeef"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... Args&gt; </td></tr>
<tr class="memitem:gaa8243af4d7bdc89e99894ef6b310aeef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#gaa8243af4d7bdc89e99894ef6b310aeef">seastar::with_scheduling_group</a> (<a class="el" href="classseastar_1_1scheduling__group.html">scheduling_group</a> sg, Func func, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:gaa8243af4d7bdc89e99894ef6b310aeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">run a callable (with some arbitrary arguments) in a scheduling group  <a href="group__future-util.html#gaa8243af4d7bdc89e99894ef6b310aeef">More...</a><br /></td></tr>
<tr class="separator:gaa8243af4d7bdc89e99894ef6b310aeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fd383361325ca4975d17b750f59e07"><td class="memTemplParams" colspan="2">template&lt;typename ExceptionFactory  = default_timeout_exception_factory, typename Clock , typename Duration , typename... T&gt; </td></tr>
<tr class="memitem:ga96fd383361325ca4975d17b750f59e07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga96fd383361325ca4975d17b750f59e07">seastar::with_timeout</a> (std::chrono::time_point&lt; Clock, Duration &gt; timeout, <a class="el" href="classseastar_1_1future.html">future</a>&lt; T... &gt; f)</td></tr>
<tr class="memdesc:ga96fd383361325ca4975d17b750f59e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for either a future, or a timeout, whichever comes first.  <a href="group__future-util.html#ga96fd383361325ca4975d17b750f59e07">More...</a><br /></td></tr>
<tr class="separator:ga96fd383361325ca4975d17b750f59e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2f3bb42cb988d4a93ced1e8bf78d64"><td class="memItemLeft" align="right" valign="top"><a id="gaaf2f3bb42cb988d4a93ced1e8bf78d64"></a>
<a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__future-util.html#gaaf2f3bb42cb988d4a93ced1e8bf78d64">seastar::now</a> ()</td></tr>
<tr class="memdesc:gaaf2f3bb42cb988d4a93ced1e8bf78d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ready future. <br /></td></tr>
<tr class="separator:gaaf2f3bb42cb988d4a93ced1e8bf78d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b981c394d2c98ead6224782f7ec00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__future-util.html#gadf2b981c394d2c98ead6224782f7ec00">seastar::yield</a> () noexcept</td></tr>
<tr class="memdesc:gadf2b981c394d2c98ead6224782f7ec00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a future which is not ready but is scheduled to resolve soon.  <a href="group__future-util.html#gadf2b981c394d2c98ead6224782f7ec00">More...</a><br /></td></tr>
<tr class="separator:gadf2b981c394d2c98ead6224782f7ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272066fe79441c0f854d2b753a0eea5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga272066fe79441c0f854d2b753a0eea5a">seastar::maybe_yield</a> () noexcept</td></tr>
<tr class="separator:ga272066fe79441c0f854d2b753a0eea5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eaca9fadeb65faa01a45f843201a9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__future-util.html#ga7eaca9fadeb65faa01a45f843201a9f0">seastar::check_for_io_immediately</a> () noexcept</td></tr>
<tr class="separator:ga7eaca9fadeb65faa01a45f843201a9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9104fe28893794e962776d8a79c4324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseastar_1_1future.html">future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__future-util.html#gae9104fe28893794e962776d8a79c4324">seastar::later</a> () noexcept</td></tr>
<tr class="memdesc:gae9104fe28893794e962776d8a79c4324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a future which is not ready but is scheduled to resolve soon.  <a href="group__future-util.html#gae9104fe28893794e962776d8a79c4324">More...</a><br /></td></tr>
<tr class="separator:gae9104fe28893794e962776d8a79c4324"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structseastar_1_1stop__iteration__tag" id="structseastar_1_1stop__iteration__tag"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structseastar_1_1stop__iteration__tag">&#9670;&nbsp;</a></span>seastar::stop_iteration_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct seastar::stop_iteration_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7eaca9fadeb65faa01a45f843201a9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eaca9fadeb65faa01a45f843201a9f0">&#9670;&nbsp;</a></span>check_for_io_immediately()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::check_for_io_immediately </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Force the reactor to check for pending I/O</p>
<p>Schedules a check for new I/O completions (disk operations completions or network packet arrival) immediately and return a future that is ready when the I/O has been polled for.</p>
<dl class="section note"><dt>Note</dt><dd>It is very rare to need to call this function. It is better to let the reactor schedule I/O polls itself. </dd>
<dd>
This has no effect on I/O polling on other shards. </dd></dl>

</div>
</div>
<a id="gae24dcdd1f1d3413cd97863a0c87ace5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24dcdd1f1d3413cd97863a0c87ace5c">&#9670;&nbsp;</a></span>do_for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename AsyncAction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::do_for_each </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AsyncAction&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function for each item in a range, sequentially (range version). </p>
<p>For each item in a range, call a function, waiting for the previous invocation to complete before calling the next one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>an <code>Container</code> object designating input range </td></tr>
    <tr><td class="paramname">action</td><td>a callable, taking a reference to objects from the range as a parameter, and returning a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code> that resolves when it is acceptable to process the next item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready future on success, or the first failed future if <code>action</code> failed. </dd></dl>

</div>
</div>
<a id="gab0e0000a074e16222f443c5b157c4cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0e0000a074e16222f443c5b157c4cd7">&#9670;&nbsp;</a></span>do_for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename AsyncAction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::do_for_each </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AsyncAction&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function for each item in a range, sequentially (iterator version). </p>
<p>For each item in a range, call a function, waiting for the previous invocation to complete before calling the next one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an <code>InputIterator</code> designating the beginning of the range </td></tr>
    <tr><td class="paramname">end</td><td>an <code>InputIterator</code> designating the endof the range </td></tr>
    <tr><td class="paramname">action</td><td>a callable, taking a reference to objects from the range as a parameter, and returning a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code> that resolves when it is acceptable to process the next item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready future on success, or the first failed future if <code>action</code> failed. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="file_demo_8cc-example.html#a6">file_demo.cc</a>.</dd>
</dl>

</div>
</div>
<a id="ga154305d8b7c89b320954885d6604f78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga154305d8b7c89b320954885d6604f78e">&#9670;&nbsp;</a></span>do_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncAction , typename StopCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::do_until </td>
          <td>(</td>
          <td class="paramtype">StopCondition&#160;</td>
          <td class="paramname"><em>stop_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AsyncAction&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invokes given action until it fails or given condition evaluates to true or fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_cond</td><td>a callable taking no arguments, returning a boolean that evalutes to true when you don't want to call <code>action</code> any longer. If <code>stop_cond</code> fails, the exception is propagated </td></tr>
    <tr><td class="paramname">action</td><td>a callable taking no arguments, returning a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a>. Will be called again as soon as the future resolves, unless the future fails, or <code>stop_cond</code> returns <code>true</code> or fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready future if we stopped successfully, or a failed future if a call to to <code>action</code> or a call to <code>stop_cond</code> failed. </dd></dl>

</div>
</div>
<a id="ga3983004a3a79b563b0609146d008ff6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3983004a3a79b563b0609146d008ff6b">&#9670;&nbsp;</a></span>do_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... More&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seastar::do_with </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">More &amp;&amp;...&#160;</td>
          <td class="paramname"><em>more</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="group__future-util.html#ga3983004a3a79b563b0609146d008ff6b">do_with()</a> holds a objects alive until a future completes, and allow the code involved in making the future complete to have easy access to this object.</p>
<p><a class="el" href="group__future-util.html#ga3983004a3a79b563b0609146d008ff6b">do_with()</a> takes multiple arguments: The last is a function returning a future. The other are temporary objects (rvalue). The function is given (a moved copy of) these temporary object, by reference, and it is ensured that the objects will not be destructed until the completion of the future returned by the function.</p>
<p><a class="el" href="group__future-util.html#ga3983004a3a79b563b0609146d008ff6b">do_with()</a> returns a future which resolves to whatever value the given future (returned by the given function) resolves to. This returned value must not contain references to the temporary object, as at that point the temporary is destructed.</p>
<dl class="section return"><dt>Returns</dt><dd>whatever the function returns </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="closeable_test_8cc-example.html#a0">closeable_test.cc</a>.</dd>
</dl>

</div>
</div>
<a id="ga515b7f03a7b2a47c682da816e187f666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga515b7f03a7b2a47c682da816e187f666">&#9670;&nbsp;</a></span>keep_doing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncAction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::keep_doing </td>
          <td>(</td>
          <td class="paramtype">AsyncAction&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoke given action until it fails.</p>
<p>Calls <code>action</code> repeatedly until it returns a failed future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a callable taking no arguments, returning a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code> that becomes ready when you wish it to be called again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a> that will resolve to the first failure of <code>action</code> </dd></dl>

</div>
</div>
<a id="gae9104fe28893794e962776d8a79c4324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9104fe28893794e962776d8a79c4324">&#9670;&nbsp;</a></span>later()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::later </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a future which is not ready but is scheduled to resolve soon. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__future-util.html#gadf2b981c394d2c98ead6224782f7ec00" title="Returns a future which is not ready but is scheduled to resolve soon.">yield()</a> instead, or <a class="el" href="group__future-util.html#ga7eaca9fadeb65faa01a45f843201a9f0">check_for_io_immediately()</a> if your really need it. </dd></dl>

</div>
</div>
<a id="ga60ad82a5fe5ca21bd9a4af17056fcfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60ad82a5fe5ca21bd9a4af17056fcfd8">&#9670;&nbsp;</a></span>map_reduce() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Mapper , typename Initial , typename Reduce &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;Initial&gt; seastar::map_reduce </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Initial&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduce&#160;</td>
          <td class="paramname"><em>reduce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous map/reduce transformation.</p>
<p>Given a range of objects, an asynchronous unary function operating on these objects, an initial value, and a binary function for reducing, <a class="el" href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">map_reduce()</a> will transform each object in the range, then invoke the the reducing function with the result.</p>
<p>Example:</p>
<p>Calculate the total size of several files:</p>
<div class="fragment"><div class="line"><a class="code" href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">map_reduce</a>(files.begin(), files.end(),</div>
<div class="line">           std::mem_fn(<a class="code" href="classseastar_1_1file.html#adb391cb352c12676b21cc6c0b4963f58">file::size</a>),</div>
<div class="line">           <span class="keywordtype">size_t</span>(0),</div>
<div class="line">           std::plus&lt;size_t&gt;())</div>
<div class="ttc" id="aclassseastar_1_1file_html_adb391cb352c12676b21cc6c0b4963f58"><div class="ttname"><a href="classseastar_1_1file.html#adb391cb352c12676b21cc6c0b4963f58">seastar::file::size</a></div><div class="ttdeci">future&lt; uint64_t &gt; size() const noexcept</div><div class="ttdoc">Gets the file size.</div></div>
<div class="ttc" id="agroup__future-util_html_gaa50a2c803cc55b3e75d8054bb5baf7fd"><div class="ttname"><a href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">seastar::map_reduce</a></div><div class="ttdeci">auto map_reduce(Iterator begin, Iterator end, Mapper &amp;&amp;mapper, Reducer &amp;&amp;r) -&gt; typename reducer_traits&lt; Reducer &gt;::future_type</div><div class="ttdef"><b>Definition:</b> map_reduce.hh:107</div></div>
</div><!-- fragment --><p>Requirements:</p><ul>
<li>Iterator: an InputIterator.</li>
<li>Mapper: unary function taking Iterator::value_type and producing a future&lt;...&gt;.</li>
<li>Initial: any value type</li>
<li>Reduce: a binary function taking two Initial values and returning an Initial</li>
</ul>
<p>Return type:</p><ul>
<li>future&lt;Initial&gt;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of object range to operate on </td></tr>
    <tr><td class="paramname">end</td><td>end of object range to operate on </td></tr>
    <tr><td class="paramname">mapper</td><td>map function to call on each object, returning a future </td></tr>
    <tr><td class="paramname">initial</td><td>initial input value to reduce function </td></tr>
    <tr><td class="paramname">reduce</td><td>binary function for merging two result values from <code>mapper</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>equivalent to <code>reduce</code>(reduce(initial, mapper(obj0)), mapper(obj1)) ...</dd></dl>
<dl class="section note"><dt>Note</dt><dd>map-reduce() schedules all invocations of both <code>mapper</code> and <code>reduce</code> on the current shard. If you want to run a function on all shards in parallel, have a look at <a class="el" href="classseastar_1_1smp.html#ac62f34a79a7c06fdc5a6939fe3943cb6">smp::invoke_on_all()</a> instead, or combine <a class="el" href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">map_reduce()</a> with <a class="el" href="classseastar_1_1smp.html#a897fe69d5d7077d13e53bb6e81d8f043">smp::submit_to()</a>. Sharded services have their own <a class="el" href="classseastar_1_1sharded.html#abf9782b54f3a3e684a50058bda32e22c">sharded::map_reduce()</a> which map-reduces across all shards. </dd></dl>

</div>
</div>
<a id="gaa50a2c803cc55b3e75d8054bb5baf7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa50a2c803cc55b3e75d8054bb5baf7fd">&#9670;&nbsp;</a></span>map_reduce() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Mapper , typename Reducer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seastar::map_reduce </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reducer &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename reducer_traits&lt;Reducer&gt;::future_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map a function over a range and reduce the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an <code>InputIterator</code> designating the beginning of the range </td></tr>
    <tr><td class="paramname">end</td><td>an <code>InputIterator</code> designating the end of the range </td></tr>
    <tr><td class="paramname">mapper</td><td>is a callable which transforms values from the iterator range into a future&lt;T&gt; </td></tr>
    <tr><td class="paramname">r</td><td>is an object which can be called with T as parameter and yields a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a> It may have a get() method which returns a value of type U which holds the result of reduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Th reduced value wrapped in a future. If the reducer has no get() method then this function returns <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>map-reduce() schedules all invocations of both <code>mapper</code> and <code>reduce</code> on the current shard. If you want to run a function on all shards in parallel, have a look at <a class="el" href="classseastar_1_1smp.html#ac62f34a79a7c06fdc5a6939fe3943cb6">smp::invoke_on_all()</a> instead, or combine <a class="el" href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">map_reduce()</a> with <a class="el" href="classseastar_1_1smp.html#a897fe69d5d7077d13e53bb6e81d8f043">smp::submit_to()</a>. Sharded services have their own <a class="el" href="classseastar_1_1sharded.html#abf9782b54f3a3e684a50058bda32e22c">sharded::map_reduce()</a> which map-reduces across all shards. </dd></dl>

</div>
</div>
<a id="gadbb7da1bed235de9fe71ec029aa42182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbb7da1bed235de9fe71ec029aa42182">&#9670;&nbsp;</a></span>map_reduce() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Mapper , typename Initial , typename Reduce &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;Initial&gt; seastar::map_reduce </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Initial&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduce&#160;</td>
          <td class="paramname"><em>reduce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous map/reduce transformation (range version).</p>
<p>Given a range of objects, an asynchronous unary function operating on these objects, an initial value, and a binary function for reducing, <a class="el" href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">map_reduce()</a> will transform each object in the range, then invoke the the reducing function with the result.</p>
<p>Example:</p>
<p>Calculate the total size of several files:</p>
<div class="fragment"><div class="line">std::vector&lt;file&gt; files = ...;</div>
<div class="line"><a class="code" href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">map_reduce</a>(files,</div>
<div class="line">           std::mem_fn(<a class="code" href="classseastar_1_1file.html#adb391cb352c12676b21cc6c0b4963f58">file::size</a>),</div>
<div class="line">           <span class="keywordtype">size_t</span>(0),</div>
<div class="line">           std::plus&lt;size_t&gt;())</div>
</div><!-- fragment --><p>Requirements:</p><ul>
<li>Iterator: an InputIterator.</li>
<li>Mapper: unary function taking Iterator::value_type and producing a future&lt;...&gt;.</li>
<li>Initial: any value type</li>
<li>Reduce: a binary function taking two Initial values and returning an Initial</li>
</ul>
<p>Return type:</p><ul>
<li>future&lt;Initial&gt;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>object range to operate on </td></tr>
    <tr><td class="paramname">mapper</td><td>map function to call on each object, returning a future </td></tr>
    <tr><td class="paramname">initial</td><td>initial input value to reduce function </td></tr>
    <tr><td class="paramname">reduce</td><td>binary function for merging two result values from <code>mapper</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>equivalent to <code>reduce</code>(reduce(initial, mapper(obj0)), mapper(obj1)) ...</dd></dl>
<dl class="section note"><dt>Note</dt><dd>map-reduce() schedules all invocations of both <code>mapper</code> and <code>reduce</code> on the current shard. If you want to run a function on all shards in parallel, have a look at <a class="el" href="classseastar_1_1smp.html#ac62f34a79a7c06fdc5a6939fe3943cb6">smp::invoke_on_all()</a> instead, or combine <a class="el" href="group__future-util.html#gaa50a2c803cc55b3e75d8054bb5baf7fd">map_reduce()</a> with <a class="el" href="classseastar_1_1smp.html#a897fe69d5d7077d13e53bb6e81d8f043">smp::submit_to()</a>. Sharded services have their own <a class="el" href="classseastar_1_1sharded.html#abf9782b54f3a3e684a50058bda32e22c">sharded::map_reduce()</a> which map-reduces across all shards. </dd></dl>

</div>
</div>
<a id="ga2681cbe7e3bc3fe21d5314644bedb474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2681cbe7e3bc3fe21d5314644bedb474">&#9670;&nbsp;</a></span>max_concurrent_for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Sentinel , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::max_concurrent_for_each </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_concurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run a maximum of <code>max_concurrent</code> tasks in parallel (iterator version).</p>
<p>Given a range [<code>begin</code>, <code>end</code>) of objects, run <code>func</code> on each <code>*i</code> in the range, and return a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a> that resolves when all the functions complete. <code>func</code> should return a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a> that indicates when it is complete. Up to <code>max_concurrent</code> invocations are performed in parallel. This does not allow the range to refer to stack objects. The caller must ensure that the range outlives the call to max_concurrent_for_each so it can be iterated in the background.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an <code>InputIterator</code> designating the beginning of the range </td></tr>
    <tr><td class="paramname">end</td><td>an <code>InputIterator</code> designating the end of the range </td></tr>
    <tr><td class="paramname">max_concurrent</td><td>maximum number of concurrent invocations of <code>func</code>, must be greater than zero. </td></tr>
    <tr><td class="paramname">func</td><td>Function to invoke with each element in the range (returning a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code> that resolves when all the function invocations complete. If one or more return an exception, the return value contains one of the exceptions. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__future-util.html#ga2681cbe7e3bc3fe21d5314644bedb474">max_concurrent_for_each()</a> schedules all invocations of <code>func</code> on the current shard. If you want to run a function on all shards in parallel, have a look at <a class="el" href="classseastar_1_1smp.html#ac62f34a79a7c06fdc5a6939fe3943cb6">smp::invoke_on_all()</a> instead. </dd></dl>

</div>
</div>
<a id="ga76b07053b6d78c646dff797b41ee912a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76b07053b6d78c646dff797b41ee912a">&#9670;&nbsp;</a></span>max_concurrent_for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::max_concurrent_for_each </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_concurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run a maximum of <code>max_concurrent</code> tasks in parallel (range version).</p>
<p>Given a range of objects, run <code>func</code> on each <code>*i</code> in the range, and return a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a> that resolves when all the functions complete. <code>func</code> should return a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a> that indicates when it is complete. Up to <code>max_concurrent</code> invocations are performed in parallel. This does not allow the range to refer to stack objects. The caller must ensure that the range outlives the call to max_concurrent_for_each so it can be iterated in the background.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>a <code>Range</code> to be processed </td></tr>
    <tr><td class="paramname">max_concurrent</td><td>maximum number of concurrent invocations of <code>func</code>, must be greater than zero. </td></tr>
    <tr><td class="paramname">func</td><td>Function to invoke with each element in the range (returning a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code> that resolves when all the function invocations complete. If one or more return an exception, the return value contains one of the exceptions. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__future-util.html#ga2681cbe7e3bc3fe21d5314644bedb474">max_concurrent_for_each()</a> schedules all invocations of <code>func</code> on the current shard. If you want to run a function on all shards in parallel, have a look at <a class="el" href="classseastar_1_1smp.html#ac62f34a79a7c06fdc5a6939fe3943cb6">smp::invoke_on_all()</a> instead. </dd></dl>

</div>
</div>
<a id="ga272066fe79441c0f854d2b753a0eea5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272066fe79441c0f854d2b753a0eea5a">&#9670;&nbsp;</a></span>maybe_yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::maybe_yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Yield the cpu if the task quota is exhausted.</p>
<p>Check if the current continuation is preempted and yield if so. Otherwise return a ready future.</p>
<dl class="section note"><dt>Note</dt><dd>Threads and coroutines (see <a class="el" href="classseastar_1_1thread.html#a7b0335e4e9ad618b351554b39665cd29" title="Yield if this thread ought to call yield() now.">seastar::thread::maybe_yield()</a> and <a class="el" href="group__future-util.html#ga272066fe79441c0f854d2b753a0eea5a">seastar::coroutine::maybe_yield()</a> have their own custom variants, and the various continuation-based loops (<a class="el" href="group__future-util.html#gab0e0000a074e16222f443c5b157c4cd7" title="Call a function for each item in a range, sequentially (iterator version).">do_for_each()</a> and similar) do this automatically. </dd></dl>

</div>
</div>
<a id="gaf687b5637cac1ef4c74c1d5344c86974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf687b5637cac1ef4c74c1d5344c86974">&#9670;&nbsp;</a></span>parallel_for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Sentinel , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::parallel_for_each </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run tasks in parallel (iterator version). </p>
<p>Given a range [<code>begin</code>, <code>end</code>) of objects, run <code>func</code> on each <code>*i</code> in the range, and return a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a> that resolves when all the functions complete. <code>func</code> should return a <a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a> that indicates when it is complete. All invocations are performed in parallel. This allows the range to refer to stack objects, but means that unlike other loops this cannot check need_preempt and can only be used with small ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an <code>InputIterator</code> designating the beginning of the range </td></tr>
    <tr><td class="paramname">end</td><td>an <code>InputIterator</code> designating the end of the range </td></tr>
    <tr><td class="paramname">func</td><td>Function to invoke with each element in the range (returning a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="classseastar_1_1future.html">future&lt;&gt;</a></code> that resolves when all the function invocations complete. If one or more return an exception, the return value contains one of the exceptions. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__future-util.html#gaf687b5637cac1ef4c74c1d5344c86974" title="Run tasks in parallel (iterator version).">parallel_for_each()</a> schedules all invocations of <code>func</code> on the current shard. If you want to run a function on all shards in parallel, have a look at <a class="el" href="classseastar_1_1smp.html#ac62f34a79a7c06fdc5a6939fe3943cb6">smp::invoke_on_all()</a> instead. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="closeable_test_8cc-example.html#a3">closeable_test.cc</a>.</dd>
</dl>

</div>
</div>
<a id="ga685902b4814947b091c3bed6535267d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685902b4814947b091c3bed6535267d9">&#9670;&nbsp;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncAction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::repeat </td>
          <td>(</td>
          <td class="paramtype">AsyncAction &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invokes given action until it fails or the function requests iteration to stop by returning <code>stop_iteration::yes</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a callable taking no arguments, returning a future&lt;stop_iteration&gt;. Will be called again as soon as the future resolves, unless the future fails, action throws, or it resolves with <code>stop_iteration::yes</code>. If <code>action</code> is an r-value it can be moved in the middle of iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready future if we stopped successfully, or a failed future if a call to to <code>action</code> failed. </dd></dl>

</div>
</div>
<a id="ga99ee1bd14b2fae297d9b81e409cfa99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ee1bd14b2fae297d9b81e409cfa99f">&#9670;&nbsp;</a></span>repeat_until_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncAction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">repeat_until_value_return_type&lt;AsyncAction&gt; seastar::repeat_until_value </td>
          <td>(</td>
          <td class="paramtype">AsyncAction&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invokes given action until it fails or the function requests iteration to stop by returning an engaged <code>future&lt;std::optional&lt;T&gt;&gt;</code> or std::optional&lt;T&gt;. The value is extracted from the <code>optional</code>, and returned, as a future, from <a class="el" href="group__future-util.html#ga99ee1bd14b2fae297d9b81e409cfa99f">repeat_until_value()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a callable taking no arguments, returning a future&lt;std::optional&lt;T&gt;&gt; or std::optional&lt;T&gt;. Will be called again as soon as the future resolves, unless the future fails, action throws, or it resolves with an engaged <code>optional</code>. If <code>action</code> is an r-value it can be moved in the middle of iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready future if we stopped successfully, or a failed future if a call to to <code>action</code> failed. The <code>optional's</code> value is returned. </dd></dl>

</div>
</div>
<a id="ga64cf7dbb446c6618955e23959ee79401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64cf7dbb446c6618955e23959ee79401">&#9670;&nbsp;</a></span>when_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FutOrFuncs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seastar::when_all </td>
          <td>(</td>
          <td class="paramtype">FutOrFuncs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fut_or_funcs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for many futures to complete, capturing possible errors (variadic version).</p>
<p>Each future can be passed directly, or a function that returns a future can be given instead.</p>
<p>If any function throws, an exceptional future is created for it.</p>
<p>Returns a tuple of futures so individual values or exceptions can be examined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fut_or_funcs</td><td>futures or functions that return futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::tuple&lt;&gt;</code> of all futures returned; when ready, all contained futures will be ready as well. </dd></dl>

</div>
</div>
<a id="gabe73d5f5520c21fd438c65f1ea506557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe73d5f5520c21fd438c65f1ea506557">&#9670;&nbsp;</a></span>when_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FutureIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;std::vector&lt;typename std::iterator_traits&lt;FutureIterator&gt;::value_type&gt; &gt; seastar::when_all </td>
          <td>(</td>
          <td class="paramtype">FutureIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FutureIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for many futures to complete, capturing possible errors (iterator version).</p>
<p>Given a range of futures as input, wait for all of them to resolve (either successfully or with an exception), and return them as a <code>std::vector</code> so individual values or exceptions can be examined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an <code>InputIterator</code> designating the beginning of the range of futures </td></tr>
    <tr><td class="paramname">end</td><td>an <code>InputIterator</code> designating the end of the range of futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::vector&lt;&gt;</code> of all the futures in the input; when ready, all contained futures will be ready as well. </dd></dl>

</div>
</div>
<a id="ga38a94c0a3e1ed93ff40960f985565053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38a94c0a3e1ed93ff40960f985565053">&#9670;&nbsp;</a></span>when_all_succeed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FutOrFuncs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seastar::when_all_succeed </td>
          <td>(</td>
          <td class="paramtype">FutOrFuncs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fut_or_funcs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for many futures to complete (variadic version).</p>
<p>Each future can be passed directly, or a function that returns a future can be given instead.</p>
<p>If any function throws, or if the returned future fails, one of the exceptions is returned by this function as a failed future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fut_or_funcs</td><td>futures or functions that return futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>future containing values of futures returned by funcs </dd></dl>

</div>
</div>
<a id="ga58711f44ded903f41611d1723bc0ee61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58711f44ded903f41611d1723bc0ee61">&#9670;&nbsp;</a></span>when_all_succeed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FutureIterator , typename  = typename std::iterator_traits&lt;FutureIterator&gt;::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seastar::when_all_succeed </td>
          <td>(</td>
          <td class="paramtype">FutureIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FutureIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for many futures to complete (iterator version).</p>
<p>Given a range of futures as input, wait for all of them to resolve, and return a future containing a vector of values of the original futures. In case any of the given futures fails one of the exceptions is returned by this function as a failed future. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an <code>InputIterator</code> designating the beginning of the range of futures </td></tr>
    <tr><td class="paramname">end</td><td>an <code>InputIterator</code> designating the end of the range of futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::vector&lt;&gt;</code> of all the valus in the input </dd></dl>

</div>
</div>
<a id="ga4f32afb5e9ab48be779615692e88e588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f32afb5e9ab48be779615692e88e588">&#9670;&nbsp;</a></span>when_all_succeed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seastar::when_all_succeed </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classseastar_1_1future.html">future</a>&lt; T &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>futures</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for many futures to complete (vector version).</p>
<p>Given a vector of futures as input, wait for all of them to resolve, and return a future containing a vector of values of the original futures.</p>
<p>In case any of the given futures fails one of the exceptions is returned by this function as a failed future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">futures</td><td>a <code>std::vector</code> containing the futures to wait for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::vector&lt;&gt;</code> of all the values in the input </dd></dl>

</div>
</div>
<a id="gab8fd3e3a0e5ba88fc4aa236494c1d00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8fd3e3a0e5ba88fc4aa236494c1d00b">&#9670;&nbsp;</a></span>with_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lock , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seastar::with_lock </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the function <code>func</code> making sure the lock <code>lock</code> is taken, and later on properly released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>the lock, which is any object having providing a lock() / unlock() semantics. Caller must make sure that it outlives <code>func</code>. </td></tr>
    <tr><td class="paramname">func</td><td>function to be executed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whatever <code>func</code> returns </dd></dl>

</div>
</div>
<a id="gaa8243af4d7bdc89e99894ef6b310aeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8243af4d7bdc89e99894ef6b310aeef">&#9670;&nbsp;</a></span>with_scheduling_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seastar::with_scheduling_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseastar_1_1scheduling__group.html">scheduling_group</a>&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>run a callable (with some arbitrary arguments) in a scheduling group </p>
<p>If the conditions are suitable (see scheduling_group::may_run_immediately()), then the function is run immediately. Otherwise, the function is queued to run when its scheduling group next runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>scheduling group that controls execution time for the function </td></tr>
    <tr><td class="paramname">func</td><td>function to run; must be movable or copyable </td></tr>
    <tr><td class="paramname">args</td><td>arguments to the function; may be copied or moved, so use <code><a class="el" href="group__utilities.html#gaf59bb3b815e7d5e88806be491cda2f1d" title="Wraps reference in a reference_wrapper.">std::ref()</a></code> to force passing references </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96fd383361325ca4975d17b750f59e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96fd383361325ca4975d17b750f59e07">&#9670;&nbsp;</a></span>with_timeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExceptionFactory  = default_timeout_exception_factory, typename Clock , typename Duration , typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a>&lt;T...&gt; seastar::with_timeout </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; Clock, Duration &gt;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseastar_1_1future.html">future</a>&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for either a future, or a timeout, whichever comes first. </p>
<p>When timeout is reached the returned future resolves with an exception produced by ExceptionFactory::timeout(). By default it is <a class="el" href="classseastar_1_1timed__out__error.html">timed_out_error</a> exception.</p>
<p>Note that timing out doesn't cancel any tasks associated with the original future. It also doesn't cancel the callback registerred on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>future to wait for </td></tr>
    <tr><td class="paramname">timeout</td><td>time point after which the returned future should be failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future which will be either resolved with f or a timeout exception </dd></dl>

</div>
</div>
<a id="gadf2b981c394d2c98ead6224782f7ec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf2b981c394d2c98ead6224782f7ec00">&#9670;&nbsp;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseastar_1_1future.html">future</a> seastar::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a future which is not ready but is scheduled to resolve soon. </p>
<p>Schedules a future to run "soon". <a class="el" href="group__future-util.html#gadf2b981c394d2c98ead6224782f7ec00" title="Returns a future which is not ready but is scheduled to resolve soon.">yield()</a> can be used to break long-but-finite loops into pieces. Note that if nothing else is runnable, It will not check for I/O, and so an infinite loop with <a class="el" href="group__future-util.html#gadf2b981c394d2c98ead6224782f7ec00" title="Returns a future which is not ready but is scheduled to resolve soon.">yield()</a> will just burn CPU. <br  />
 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
