<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Seastar: RPC streaming</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Seastar
   </div>
   <div id="projectbrief">High performance C++ framework for concurrent servers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">RPC streaming </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md32"></a>
Streaming API</h1>
<h2><a class="anchor" id="autotoc_md33"></a>
Sink and Source</h2>
<p>Basic element of streaming API is <code>rpc::sink</code> and <code>rpc::source</code>. The former is used to send data and the later is to receive it. Client and server has their own pair of sink and source. <code>rpc::sink</code> and <code>rpc::source</code> are templated classes where template parameters describe a type of the data that is sent/received. For instance the sink that is used to send messages containing <code>int</code> and <code>long</code> will be of a type <code>rpc::sink&lt;int, long&gt;</code>. The opposite end of the stream will have a source of the type <code>rpc::source&lt;int, long&gt;</code> which will be used to receive those messages. Messages are received at a source as <code>std::optional</code> containing an actual message as an <code>std::tuple</code>. Unengaged optional means EOS (end of stream) - the stream was closed by a peer. If error happen before EOS is received a receiver cannot be sure it received all the data.</p>
<p>To send the data using <code>rpc::source&lt;int, long&gt;</code> one can write (assuming <code><a class="el" href="group__thread-module.html#gade193638732df7e9db1d8de16ec3ac7f">seastar::async</a></code> context):</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (has_data()) {</div>
<div class="line">    <span class="keywordtype">int</span> data1 = get_data1();</div>
<div class="line">    <span class="keywordtype">long</span> data2 = get_data2();</div>
<div class="line">    sink(data1, data2).get(); <span class="comment">// sends data</span></div>
<div class="line">}</div>
<div class="line">sink.close().get(); <span class="comment">// closes stream</span></div>
</div><!-- fragment --><p>To receive:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    std:optional&lt;std::tuple&lt;int, long&gt;&gt; data = source().get0();</div>
<div class="line">    <span class="keywordflow">if</span> (!data) {</div>
<div class="line">       <span class="comment">// unengaged optional means EOS</span></div>
<div class="line">       <span class="keywordflow">break</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">       <span class="keyword">auto</span> [data1, data2] = *data;</div>
<div class="line">       <span class="comment">// process data</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
Creating a stream</h2>
<p>To open an RPC stream one needs RPC client to be created already. The stream will be associated with the client and will be aborted if the client is closed before streaming is. Given RPC client <code>rc</code>, and a <code>serializer</code> class that models the Serializer concept (as explained in the rpc::protocol class), one creates <code>rpc::sink</code> as follows (again assuming <code><a class="el" href="group__thread-module.html#gade193638732df7e9db1d8de16ec3ac7f">seastar::async</a></code> context):</p>
<div class="fragment"><div class="line">rpc::sink&lt;int, long&gt; sink = rc.make_stream_sink&lt;serializer, int, <span class="keywordtype">long</span>&gt;().get0();</div>
</div><!-- fragment --><p>Now the client has the sink that can be used for streaming data to a server, but how the server will get a corresponding <code>rpc::source</code> to read it? For that the sink should be passed to the server by an RPC call. To receive a sink a server should register an RPC handler that will be used to receive it along with any auxiliary information deemed necessary. To receive the sink above one may register an RPC handler like that:</p>
<div class="fragment"><div class="line">rpc_proto.register_handler(1, [] (<span class="keywordtype">int</span> aux_data, rpc::source&lt;int, long&gt; source) {</div>
<div class="line">});</div>
</div><!-- fragment --><p>Notice that <code>rpc::sink</code> is received as an <code>rpc::source</code> since at the server side it will be used for receive. Now all is left to do is for the client to invoke this RPC handler with aux_data and the sink.</p>
<p>But what about communicating in another direction: from a server to a client. For that a server also has to have a sink and a client has to have a source and since messages in this direction may be of a different type than from client to server the sink and the source may be of a different type as well.</p>
<p>Server initiates creation of a communication channel in another direction. It does this by creating a sink from the source it receives and returning the sink from RPC handler which will cause it to be received as a source by a client. Lets look at the full example where server want to send message containing sstring to a client.</p>
<p>Server handler will look like that:</p>
<div class="fragment"><div class="line">rpc_proto.register_handler(1, [] (<span class="keywordtype">int</span> aux_data, rpc::source&lt;int, long&gt; source) {</div>
<div class="line">    rpc::sink&lt;sstring&gt; sink = source.make_sink&lt;serializer, sstring&gt;();</div>
<div class="line">    <span class="comment">// use sink and source asynchronously</span></div>
<div class="line">    <span class="keywordflow">return</span> sink;</div>
<div class="line">});</div>
</div><!-- fragment --><p>Client code will be:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> rpc_call = rpc_proto.make_client&lt;rpc::source&lt;sstring&gt; (<span class="keywordtype">int</span>, rpc::sink&lt;int&gt;)&gt;(1);</div>
<div class="line">rpc::sink&lt;int, long&gt; sink = rc.make_stream_sink&lt;serializer, int, <span class="keywordtype">long</span>&gt;().get0();</div>
<div class="line">rpc::source&lt;sstring&gt; source = rpc_call(rc, aux_data, sink).get0();</div>
<div class="line"><span class="comment">// use sink and source here</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md35"></a>
Implementation notes</h1>
<h2><a class="anchor" id="autotoc_md36"></a>
RPC stream creation</h2>
<p>RPC stream is implemented as a separate TCP connection. RPC server knows that a connection will be used for streaming if during RPC negotiation <code>Stream parent</code> feature is present. The feature will contain ID of an RPC client that was used to create the stream.</p>
<p>So in the example from previous chapter:</p>
<div class="fragment"><div class="line">rpc::sink&lt;int, long&gt; sink = rc.make_stream_sink&lt;serializer, int, <span class="keywordtype">long</span>&gt;().get0();</div>
</div><!-- fragment --><p>the call will initiate a new TCP connection to the same server <code>rc</code> is connected to. During RPC protocol negotiation this connection will have <code>Stream parent</code> feature with <code>rc</code>'s ID as a value.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Passing sink/source over RPC call</h2>
<p>When <code>rpc::sink</code> is sent over RPC call it is serialized as its connection ID. Server's RPC handler then lookups the connection and creates an <code>rpc::source</code> from it. When RPC handler returns <code>rpc::sink</code> the same happens in other direction. <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
