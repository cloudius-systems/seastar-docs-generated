<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Seastar: seastar::memory Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Seastar
   </div>
   <div id="projectbrief">High performance C++ framework for concurrent servers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceseastar.html">seastar</a></li><li class="navelem"><a class="el" href="namespaceseastar_1_1memory.html">memory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">seastar::memory Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low-level memory management support</p>
<p>The <code>memory</code> namespace provides functions and classes for interfacing with the seastar memory allocator.</p>
<p>The seastar memory allocator splits system memory into a pool per logical core (lcore). Memory allocated one an lcore should be freed on the same lcore; failing to do so carries a severe performance penalty. It is possible to share memory with another core, but this should be limited to avoid cache coherency traffic. You can obtain the memory layout of the current shard with get_memory_layout().</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Critical allocation scopes</h2>
<p>Seastar supports marking scopes as critical allocation scopes for the purpose of special treatment from various memory related utilities. See <a class="el" href="namespaceseastar_1_1memory.html">scoped_critical_alloc_section</a>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Diagnostics and debugging features</h2>
<h3><a class="anchor" id="autotoc_md5"></a>
Allocation failure injector</h3>
<p>Allows injecting allocation failures for testing resiliency against allocation failures, or exceptions in general. See:</p><ul>
<li><a class="el" href="classseastar_1_1memory_1_1alloc__failure__injector.html">alloc_failure_injector</a></li>
<li><a class="el" href="namespaceseastar_1_1memory.html#a1d586eb8e9aac6dcd2ad2cd686a51717">with_allocation_failures()</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md6"></a>
Large allocation warning</h3>
<p>Large allocations put great pressure on the allocator which might be unable to serve them even if there is enough memory available, due to memory fragmentation. This is especially relevant for long-running applications, the kind of applications that are typically built with seastar. This feature allows finding these large by logging a warning on large allocations, with the stacktrace of the. See:</p><ul>
<li><a class="el" href="namespaceseastar_1_1memory.html#a0f42296c2fe94f53fbdca0d62dd07679">set_large_allocation_warning_threshold()</a></li>
<li><a class="el" href="namespaceseastar_1_1memory.html#a17e2e9ff7c849acc4b9a4cb49c65e906">get_large_allocation_warning_threshold()</a></li>
<li><a class="el" href="classseastar_1_1memory_1_1scoped__large__allocation__warning__threshold.html">scoped_large_allocation_warning_threshold</a></li>
<li><a class="el" href="classseastar_1_1memory_1_1scoped__large__allocation__warning__disable.html">scoped_large_allocation_warning_disable</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md7"></a>
Heap profiling</h3>
<p>Heap profiling allows finding out how memory is used by your application, by recording the stacktrace of all allocations. See:</p><ul>
<li><a class="el" href="namespaceseastar_1_1memory.html#a651ca5e69660efb9d05c1d3edc4c1fd0">set_heap_profiling_enabled()</a></li>
<li><a class="el" href="classseastar_1_1memory_1_1scoped__heap__profiling.html">scoped_heap_profiling</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md8"></a>
Abort on allocation failure</h3>
<p>Often, the best way to debug an allocation failure is a coredump. This feature allows dumping core on allocation failures, containing the stack of the failed allocation, by means of aborting. To enable this behavior, set <code>abort_on_seastar_bad_alloc</code> in <code><a class="el" href="structseastar_1_1reactor__options.html" title="Configuration for the reactor.">reactor_options</a></code> or pass the <code>--abort-on-seastar-bad-alloc</code> command line flag. Additionally, applications may enable or disable this functionality globally at runtime by calling <code><a class="el" href="namespaceseastar_1_1memory.html#a6612139edb36977f770061377a95a371" title="Set the global state of the abort on allocation failure behavior.">set_abort_on_allocation_failure()</a></code>.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Dump diagnostics report</h3>
<p>Dump a diagnostic report of the state of the seastar allocator upon allocation failure. The report is dumped with the <code>seastar_memory</code> logger, with debug level. You can configure a report to be dumped with error level on certain allocation kinds, see:</p><ul>
<li><a class="el" href="namespaceseastar_1_1memory.html#a52e889cff8bbeaecb5231a923e3716c7" title="Configure when memory diagnostics are dumped.">set_dump_memory_diagnostics_on_alloc_failure_kind()</a></li>
<li><a class="el" href="namespaceseastar_1_1memory.html#aec131d713d157f690d3164cdc5e76b2c" title="Set a producer of additional diagnostic information.">set_additional_diagnostics_producer()</a></li>
<li><a class="el" href="namespaceseastar_1_1memory.html#a862d31943a98710575e7df67396f984b">generate_memory_diagnostics_report()</a></li>
</ul>
<p>The diagnostics report dump can be configured with the command line/configuration file via the <code>dump-memory-diagnostics-on-alloc-failure-kind</code> command-line flag/configuration item. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1memory_1_1statistics.html">statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory allocation statistics.  <a href="classseastar_1_1memory_1_1statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structseastar_1_1memory_1_1memory__layout"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#structseastar_1_1memory_1_1memory__layout">memory_layout</a></td></tr>
<tr class="separator:structseastar_1_1memory_1_1memory__layout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1memory_1_1scoped__large__allocation__warning__threshold.html">scoped_large_allocation_warning_threshold</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a different large allocation warning threshold for a scope.  <a href="classseastar_1_1memory_1_1scoped__large__allocation__warning__threshold.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1memory_1_1scoped__large__allocation__warning__disable.html">scoped_large_allocation_warning_disable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable large allocation warnings for a scope.  <a href="classseastar_1_1memory_1_1scoped__large__allocation__warning__disable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1memory_1_1scoped__heap__profiling.html">scoped_heap_profiling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseastar_1_1memory_1_1alloc__failure__injector.html">alloc_failure_injector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structseastar_1_1memory_1_1disable__failure__guard"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#structseastar_1_1memory_1_1disable__failure__guard">disable_failure_guard</a></td></tr>
<tr class="separator:structseastar_1_1memory_1_1disable__failure__guard"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structseastar_1_1memory_1_1scoped__critical__alloc__section"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#structseastar_1_1memory_1_1scoped__critical__alloc__section">scoped_critical_alloc_section</a></td></tr>
<tr class="separator:structseastar_1_1memory_1_1scoped__critical__alloc__section"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0d4cda76b87090a734ce3f2cfd19f1d8"><td class="memItemLeft" align="right" valign="top"><a id="a0d4cda76b87090a734ce3f2cfd19f1d8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a0d4cda76b87090a734ce3f2cfd19f1d8">memory_diagnostics_writer</a> = <a class="el" href="namespaceseastar.html#classseastar_1_1noncopyable__function">noncopyable_function</a>&lt; void(std::string_view)&gt;</td></tr>
<tr class="memdesc:a0d4cda76b87090a734ce3f2cfd19f1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor which writes its argument into the diagnostics report. <br /></td></tr>
<tr class="separator:a0d4cda76b87090a734ce3f2cfd19f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2411b00801406f50acb3a8bc78f32400"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400">alloc_failure_kind</a> { <a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a>
, <a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400a7e85bcb66fb9a809d5ab4f62a8b8bea8">critical</a>
, <a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400aa181a603769c1f98ad927e7367c7aa51">all</a>
 }</td></tr>
<tr class="memdesc:a2411b00801406f50acb3a8bc78f32400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of allocation failures to dump diagnostics report for.  <a href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400">More...</a><br /></td></tr>
<tr class="separator:a2411b00801406f50acb3a8bc78f32400"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6612139edb36977f770061377a95a371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a6612139edb36977f770061377a95a371">set_abort_on_allocation_failure</a> (bool enabled)</td></tr>
<tr class="memdesc:a6612139edb36977f770061377a95a371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global state of the abort on allocation failure behavior.  <a href="namespaceseastar_1_1memory.html#a6612139edb36977f770061377a95a371">More...</a><br /></td></tr>
<tr class="separator:a6612139edb36977f770061377a95a371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736d66a55005b21df25d239f955f9bfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a736d66a55005b21df25d239f955f9bfd">is_abort_on_allocation_failure</a> ()</td></tr>
<tr class="memdesc:a736d66a55005b21df25d239f955f9bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the abort on allocation failure mode.  <a href="namespaceseastar_1_1memory.html#a736d66a55005b21df25d239f955f9bfd">More...</a><br /></td></tr>
<tr class="separator:a736d66a55005b21df25d239f955f9bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eab70c73ed53fe3f4b8324b16e4ca02"><td class="memItemLeft" align="right" valign="top"><a id="a1eab70c73ed53fe3f4b8324b16e4ca02"></a>
<a class="el" href="classseastar_1_1memory_1_1statistics.html">statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a1eab70c73ed53fe3f4b8324b16e4ca02">stats</a> ()</td></tr>
<tr class="memdesc:a1eab70c73ed53fe3f4b8324b16e4ca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture a snapshot of memory allocation statistics for this lcore. <br /></td></tr>
<tr class="separator:a1eab70c73ed53fe3f4b8324b16e4ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa798dd0867611924765e79abb497518"><td class="memItemLeft" align="right" valign="top"><a id="afa798dd0867611924765e79abb497518"></a>
<a class="el" href="namespaceseastar_1_1memory.html#structseastar_1_1memory_1_1memory__layout">memory::memory_layout</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_memory_layout</b> ()</td></tr>
<tr class="separator:afa798dd0867611924765e79abb497518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92bd57e61960c5f568ebeb31ebccea"><td class="memItemLeft" align="right" valign="top"><a id="a0c92bd57e61960c5f568ebeb31ebccea"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a0c92bd57e61960c5f568ebeb31ebccea">free_memory</a> ()</td></tr>
<tr class="memdesc:a0c92bd57e61960c5f568ebeb31ebccea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of free memory in bytes. <br /></td></tr>
<tr class="separator:a0c92bd57e61960c5f568ebeb31ebccea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252f7b05a03f6dd410951c1109f17ad9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a252f7b05a03f6dd410951c1109f17ad9">min_free_memory</a> ()</td></tr>
<tr class="separator:a252f7b05a03f6dd410951c1109f17ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2042dcbf8cc2e53f199604f9ac4f64dd"><td class="memItemLeft" align="right" valign="top"><a id="a2042dcbf8cc2e53f199604f9ac4f64dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a2042dcbf8cc2e53f199604f9ac4f64dd">set_min_free_pages</a> (size_t pages)</td></tr>
<tr class="memdesc:a2042dcbf8cc2e53f199604f9ac4f64dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of free memory low water mark in memory::page_size units. <br /></td></tr>
<tr class="separator:a2042dcbf8cc2e53f199604f9ac4f64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f42296c2fe94f53fbdca0d62dd07679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a0f42296c2fe94f53fbdca0d62dd07679">set_large_allocation_warning_threshold</a> (size_t threshold)</td></tr>
<tr class="separator:a0f42296c2fe94f53fbdca0d62dd07679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e2e9ff7c849acc4b9a4cb49c65e906"><td class="memItemLeft" align="right" valign="top"><a id="a17e2e9ff7c849acc4b9a4cb49c65e906"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a17e2e9ff7c849acc4b9a4cb49c65e906">get_large_allocation_warning_threshold</a> ()</td></tr>
<tr class="memdesc:a17e2e9ff7c849acc4b9a4cb49c65e906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current large allocation warning threshold. <br /></td></tr>
<tr class="separator:a17e2e9ff7c849acc4b9a4cb49c65e906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af07da9a57aa714469426706c69d876"><td class="memItemLeft" align="right" valign="top"><a id="a9af07da9a57aa714469426706c69d876"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a9af07da9a57aa714469426706c69d876">disable_large_allocation_warning</a> ()</td></tr>
<tr class="memdesc:a9af07da9a57aa714469426706c69d876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable large allocation warnings. <br /></td></tr>
<tr class="separator:a9af07da9a57aa714469426706c69d876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651ca5e69660efb9d05c1d3edc4c1fd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a651ca5e69660efb9d05c1d3edc4c1fd0">set_heap_profiling_enabled</a> (bool)</td></tr>
<tr class="separator:a651ca5e69660efb9d05c1d3edc4c1fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c0375f780dc55b9fa5d5181bb3f48f"><td class="memItemLeft" align="right" valign="top"><a id="ae4c0375f780dc55b9fa5d5181bb3f48f"></a>
<a class="el" href="classseastar_1_1memory_1_1alloc__failure__injector.html">alloc_failure_injector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#ae4c0375f780dc55b9fa5d5181bb3f48f">local_failure_injector</a> ()</td></tr>
<tr class="memdesc:ae4c0375f780dc55b9fa5d5181bb3f48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shard-local <a class="el" href="classseastar_1_1memory_1_1alloc__failure__injector.html">alloc_failure_injector</a> instance. <br /></td></tr>
<tr class="separator:ae4c0375f780dc55b9fa5d5181bb3f48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bff02cb23c550cd501bd59d718c0afe"><td class="memItemLeft" align="right" valign="top"><a id="a2bff02cb23c550cd501bd59d718c0afe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a2bff02cb23c550cd501bd59d718c0afe">on_alloc_point</a> ()</td></tr>
<tr class="memdesc:a2bff02cb23c550cd501bd59d718c0afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a point in code which should be considered for failure injection. <br /></td></tr>
<tr class="separator:a2bff02cb23c550cd501bd59d718c0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d586eb8e9aac6dcd2ad2cd686a51717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a1d586eb8e9aac6dcd2ad2cd686a51717">with_allocation_failures</a> (<a class="el" href="namespaceseastar.html#classseastar_1_1noncopyable__function">noncopyable_function</a>&lt; void()&gt; func)</td></tr>
<tr class="separator:a1d586eb8e9aac6dcd2ad2cd686a51717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828aca7b8b271a95db00958bc981feeb"><td class="memItemLeft" align="right" valign="top"><a id="a828aca7b8b271a95db00958bc981feeb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_critical_alloc_section</b> ()</td></tr>
<tr class="separator:a828aca7b8b271a95db00958bc981feeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e889cff8bbeaecb5231a923e3716c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a52e889cff8bbeaecb5231a923e3716c7">set_dump_memory_diagnostics_on_alloc_failure_kind</a> (<a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400">alloc_failure_kind</a>)</td></tr>
<tr class="memdesc:a52e889cff8bbeaecb5231a923e3716c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure when memory diagnostics are dumped.  <a href="namespaceseastar_1_1memory.html#a52e889cff8bbeaecb5231a923e3716c7">More...</a><br /></td></tr>
<tr class="separator:a52e889cff8bbeaecb5231a923e3716c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f15de0251b7488491dcf61aa028469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a63f15de0251b7488491dcf61aa028469">set_dump_memory_diagnostics_on_alloc_failure_kind</a> (std::string_view)</td></tr>
<tr class="memdesc:a63f15de0251b7488491dcf61aa028469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure when memory diagnostics are dumped.  <a href="namespaceseastar_1_1memory.html#a63f15de0251b7488491dcf61aa028469">More...</a><br /></td></tr>
<tr class="separator:a63f15de0251b7488491dcf61aa028469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec131d713d157f690d3164cdc5e76b2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#aec131d713d157f690d3164cdc5e76b2c">set_additional_diagnostics_producer</a> (<a class="el" href="namespaceseastar.html#classseastar_1_1noncopyable__function">noncopyable_function</a>&lt; void(<a class="el" href="namespaceseastar_1_1memory.html#a0d4cda76b87090a734ce3f2cfd19f1d8">memory_diagnostics_writer</a>)&gt; producer)</td></tr>
<tr class="memdesc:aec131d713d157f690d3164cdc5e76b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a producer of additional diagnostic information.  <a href="namespaceseastar_1_1memory.html#aec131d713d157f690d3164cdc5e76b2c">More...</a><br /></td></tr>
<tr class="separator:aec131d713d157f690d3164cdc5e76b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862d31943a98710575e7df67396f984b"><td class="memItemLeft" align="right" valign="top">sstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseastar_1_1memory.html#a862d31943a98710575e7df67396f984b">generate_memory_diagnostics_report</a> ()</td></tr>
<tr class="separator:a862d31943a98710575e7df67396f984b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structseastar_1_1memory_1_1memory__layout" id="structseastar_1_1memory_1_1memory__layout"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structseastar_1_1memory_1_1memory__layout">&#9670;&nbsp;</a></span>seastar::memory::memory_layout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct seastar::memory::memory_layout</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a4eeecf9e9acbe4d7a9349a07f8af78c3"></a>uintptr_t</td>
<td class="fieldname">
end</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a87cf7a4fd4aa9c1c9596e99246e6564f"></a>uintptr_t</td>
<td class="fieldname">
start</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structseastar_1_1memory_1_1disable__failure__guard" id="structseastar_1_1memory_1_1disable__failure__guard"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structseastar_1_1memory_1_1disable__failure__guard">&#9670;&nbsp;</a></span>seastar::memory::disable_failure_guard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct seastar::memory::disable_failure_guard</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a307c4e9ea4c3b473ca164463edf78c69"></a><a class="el" href="namespaceseastar_1_1memory.html#structseastar_1_1memory_1_1scoped__critical__alloc__section">scoped_critical_alloc_section</a></td>
<td class="fieldname">
cs</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structseastar_1_1memory_1_1scoped__critical__alloc__section" id="structseastar_1_1memory_1_1scoped__critical__alloc__section"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structseastar_1_1memory_1_1scoped__critical__alloc__section">&#9670;&nbsp;</a></span>seastar::memory::scoped_critical_alloc_section</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct seastar::memory::scoped_critical_alloc_section</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2411b00801406f50acb3a8bc78f32400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2411b00801406f50acb3a8bc78f32400">&#9670;&nbsp;</a></span>alloc_failure_kind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400">seastar::memory::alloc_failure_kind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kind of allocation failures to dump diagnostics report for. </p>
<p>Note that if the seastar_memory logger is set to level debug, there will be a report dumped for any allocation failure, regardless of this configuration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2411b00801406f50acb3a8bc78f32400a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p>Dump diagnostic error report for none of the allocation failures. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2411b00801406f50acb3a8bc78f32400a7e85bcb66fb9a809d5ab4f62a8b8bea8"></a>critical&#160;</td><td class="fielddoc"><p>Dump diagnostic error report for critical allocation failures, see <a class="el" href="namespaceseastar_1_1memory.html">scoped_critical_alloc_section</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2411b00801406f50acb3a8bc78f32400aa181a603769c1f98ad927e7367c7aa51"></a>all&#160;</td><td class="fielddoc"><p>Dump diagnostic error report for all the allocation failures. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a862d31943a98710575e7df67396f984b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862d31943a98710575e7df67396f984b">&#9670;&nbsp;</a></span>generate_memory_diagnostics_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sstring seastar::memory::generate_memory_diagnostics_report </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate and return a diagnostics report as a string.</p>
<p>Note that contrary to the automated report generation (triggered by allocation failure), this method does allocate memory and can fail in low-memory conditions. </p>

</div>
</div>
<a id="a736d66a55005b21df25d239f955f9bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736d66a55005b21df25d239f955f9bfd">&#9670;&nbsp;</a></span>is_abort_on_allocation_failure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool seastar::memory::is_abort_on_allocation_failure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the abort on allocation failure mode. </p>
<p>Return true if the global abort on allocation failure behavior is enabled, or false otherwise. Always returns false if the default (system) allocator is being used. </p>

</div>
</div>
<a id="a252f7b05a03f6dd410951c1109f17ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252f7b05a03f6dd410951c1109f17ad9">&#9670;&nbsp;</a></span>min_free_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t seastar::memory::min_free_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of free memory low water mark in bytes. When free memory is below this value, reclaimers are invoked until it goes above again. </p>

</div>
</div>
<a id="a6612139edb36977f770061377a95a371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6612139edb36977f770061377a95a371">&#9670;&nbsp;</a></span>set_abort_on_allocation_failure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seastar::memory::set_abort_on_allocation_failure </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global state of the abort on allocation failure behavior. </p>
<p>If enabled, an allocation failure (i.e., the requested memory could not be allocated even after reclaim was attempted), will generally result in <code>abort()</code> being called. If disabled, the failure is reported to the caller, e.g., by throwing a <code>std::bad_alloc</code> for C++ allocations such as new, or returning a null pointer from malloc.</p>
<p>Note that even if the global state is set to enabled, the <code>disable_abort_on_alloc_failure_temporarily</code> class may override the behavior tepmorarily on a given shard. That is, abort only occurs if abort is globablly enabled on this shard <em>and</em> there are no <code>disable_abort_on_alloc_failure_temporarily</code> objects currently alive on this shard. </p>

</div>
</div>
<a id="aec131d713d157f690d3164cdc5e76b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec131d713d157f690d3164cdc5e76b2c">&#9670;&nbsp;</a></span>set_additional_diagnostics_producer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seastar::memory::set_additional_diagnostics_producer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseastar.html#classseastar_1_1noncopyable__function">noncopyable_function</a>&lt; void(<a class="el" href="namespaceseastar_1_1memory.html#a0d4cda76b87090a734ce3f2cfd19f1d8">memory_diagnostics_writer</a>)&gt;&#160;</td>
          <td class="paramname"><em>producer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a producer of additional diagnostic information. </p>
<p>This allows the application running on top of seastar to add its own part to the diagnostics dump. The application can supply higher level diagnostics information, that might help explain how the memory was consumed.</p>
<p>The application specific part will be added just below the main stats (free/used/total memory).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>- the functor to produce the additional diagnostics, specific to the application, to be added to the generated report. The producer is passed a writer functor, which it can use to add its parts to the report.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As the report is generated at a time when allocations are failing, the producer should try as hard as possible to not allocate while producing the output. </dd></dl>

</div>
</div>
<a id="a52e889cff8bbeaecb5231a923e3716c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e889cff8bbeaecb5231a923e3716c7">&#9670;&nbsp;</a></span>set_dump_memory_diagnostics_on_alloc_failure_kind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seastar::memory::set_dump_memory_diagnostics_on_alloc_failure_kind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400">alloc_failure_kind</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure when memory diagnostics are dumped. </p>
<p>See <a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400">alloc_failure_kind</a> on available options. Applies configuration on all shards. </p>

</div>
</div>
<a id="a63f15de0251b7488491dcf61aa028469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f15de0251b7488491dcf61aa028469">&#9670;&nbsp;</a></span>set_dump_memory_diagnostics_on_alloc_failure_kind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seastar::memory::set_dump_memory_diagnostics_on_alloc_failure_kind </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure when memory diagnostics are dumped. </p>
<p>String version. See <a class="el" href="namespaceseastar_1_1memory.html#a2411b00801406f50acb3a8bc78f32400">alloc_failure_kind</a> on available options. Applies configuration on all shards. </p>

</div>
</div>
<a id="a651ca5e69660efb9d05c1d3edc4c1fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651ca5e69660efb9d05c1d3edc4c1fd0">&#9670;&nbsp;</a></span>set_heap_profiling_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seastar::memory::set_heap_profiling_enabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/disable heap profiling.</p>
<p>In order to use heap profiling you have to define <code>SEASTAR_HEAPPROF</code>. Heap profiling data is not currently exposed via an API for inspection, instead it was designed to be inspected from a debugger. For an example script that makes use of the heap profiling data see <a href="https://github.com/scylladb/scylla/blob/e1b22b6a4c56b4f1d0adf65d1a11db4bcb51fe7d/scylla-gdb.py#L1439">scylla-gdb.py</a> This script can generate either textual representation of the data, or a zoomable flame graph (<a href="https://github.com/scylladb/scylla/wiki/Seastar-heap-profiler">flame graph generation instructions</a>, <a href="https://user-images.githubusercontent.com/1389273/72920437-f0cf8a80-3d51-11ea-92f0-f3dbeb698871.png">example flame graph</a>). </p>

</div>
</div>
<a id="a0f42296c2fe94f53fbdca0d62dd07679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f42296c2fe94f53fbdca0d62dd07679">&#9670;&nbsp;</a></span>set_large_allocation_warning_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seastar::memory::set_large_allocation_warning_threshold </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable the large allocation warning threshold.</p>
<p>Warn when allocation above a given threshold are performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>size (in bytes) above which an allocation will be logged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d586eb8e9aac6dcd2ad2cd686a51717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d586eb8e9aac6dcd2ad2cd686a51717">&#9670;&nbsp;</a></span>with_allocation_failures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seastar::memory::with_allocation_failures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseastar.html#classseastar_1_1noncopyable__function">noncopyable_function</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Repeatedly run func with allocation failures</p>
<p>Initially, allocations start to fail immediately. In each subsequent run the failures start one allocation later. This returns when func is run and no allocation failures are detected. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
